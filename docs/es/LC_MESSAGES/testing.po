# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010 Pallets
# This file is distributed under the same license as the Flask package.
# FIRST AUTHOR <pedrotorcattsoto@gmail.com>, 2021.
#
msgid ""
msgstr ""
"Project-Id-Version: Flask 2.0.x\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-05-27 07:20-0400\n"
"PO-Revision-Date: 2022-02-15 21:58-0400\n"
"Language-Team: es_LA <pedrotorcattsoto@gmail.com>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"Last-Translator: Pedro Torcatt <pedrotorcattsoto@gmail.com>\n"
"Language: es\n"
"X-Generator: Poedit 3.0\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../testing.rst:2
msgid "Testing Flask Applications"
msgstr "Prueba de aplicaciones Flask"

#: ../../testing.rst:4
msgid "**Something that is untested is broken.**"
msgstr "**Algo que no está probado está roto.**"

#: ../../testing.rst:6
msgid ""
"The origin of this quote is unknown and while it is not entirely correct, it "
"is also not far from the truth.  Untested applications make it hard to improve "
"existing code and developers of untested applications tend to become pretty "
"paranoid.  If an application has automated tests, you can safely make changes "
"and instantly know if anything breaks."
msgstr ""
"El origen de esta cita es desconocido y, aunque no es del todo correcta, "
"tampoco está lejos de la verdad. Las aplicaciones no probadas dificultan la "
"mejora del código existente y los desarrolladores de aplicaciones no probadas "
"tienden a volverse bastante paranoicos. Si una aplicación tiene pruebas "
"automatizadas, puedes hacer cambios con seguridad y saber al instante si algo "
"se rompe."

#: ../../testing.rst:12
msgid ""
"Flask provides a way to test your application by exposing the Werkzeug test :"
"class:`~werkzeug.test.Client` and handling the context locals for you. You can "
"then use that with your favourite testing solution."
msgstr ""
"Flask proporciona una manera de probar su aplicación mediante la exposición de "
"la prueba Werkzeug :class:`~werkzeug.test.Client` y el manejo de los locales "
"de contexto para usted. Puedes utilizarlo con tu solución de pruebas favorita."

#: ../../testing.rst:16
msgid ""
"In this documentation we will use the `pytest`_ package as the base framework "
"for our tests. You can install it with ``pip``, like so::"
msgstr ""
"En esta documentación utilizaremos el paquete `pytest`_ como marco base para "
"nuestras pruebas. Puedes instalarlo con ``pip``, así::"

#: ../../testing.rst:24
msgid "The Application"
msgstr "La aplicación"

#: ../../testing.rst:26
msgid ""
"First, we need an application to test; we will use the application from the :"
"doc:`tutorial/index`. If you don't have that application yet, get the source "
"code from :gh:`the examples <examples/tutorial>`."
msgstr ""
"En primer lugar, necesitamos una aplicación para probar; utilizaremos la "
"aplicación del :doc:`tutorial/index`. Si aún no tienes esa aplicación, obtén "
"el código fuente de :gh:`los ejemplos <examples/tutorial>`."

#: ../../testing.rst:30
msgid ""
"So that we can import the module ``flaskr`` correctly, we need to run ``pip "
"install -e .`` in the folder ``tutorial``."
msgstr ""
"Para poder importar el módulo ``flaskr`` correctamente, necesitamos ejecutar "
"``pip install -e .`` en la carpeta ``tutorial``."

#: ../../testing.rst:34
msgid "The Testing Skeleton"
msgstr "El esqueleto de las pruebas"

#: ../../testing.rst:36
msgid ""
"We begin by adding a tests directory under the application root.  Then create "
"a Python file to store our tests (:file:`test_flaskr.py`). When we format the "
"filename like ``test_*.py``, it will be auto-discoverable by pytest."
msgstr ""
"Comenzamos añadiendo un directorio de pruebas bajo la raíz de la aplicación. "
"Luego creamos un archivo Python para almacenar nuestras pruebas (:file:"
"`prueba_flaskr.py`). Si formateamos el nombre del archivo como ``test_*.py``, "
"será autodescubierto por pytest."

#: ../../testing.rst:41
msgid ""
"Next, we create a `pytest fixture`_ called :func:`client` that configures the "
"application for testing and initializes a new database::"
msgstr ""
"A continuación, creamos un `pytest fixture`_ llamado :func:`client` que "
"configura la aplicación para las pruebas e inicializa una nueva base de datos::"

#: ../../testing.rst:66
msgid ""
"This client fixture will be called by each individual test.  It gives us a "
"simple interface to the application, where we can trigger test requests to the "
"application.  The client will also keep track of cookies for us."
msgstr ""
"Este fixture cliente será llamado por cada prueba individual. Nos da una "
"interfaz simple a la aplicación, donde podemos lanzar peticiones de prueba a "
"la aplicación. El cliente también mantendrá un seguimiento de las cookies para "
"nosotros."

#: ../../testing.rst:70
msgid ""
"During setup, the ``TESTING`` config flag is activated.  What this does is "
"disable error catching during request handling, so that you get better error "
"reports when performing test requests against the application."
msgstr ""
"Durante la configuración, se activa la bandera de configuración ``TESTING``. "
"Esto hace que se desactive la captura de errores durante la gestión de las "
"solicitudes, de modo que se obtengan mejores informes de errores cuando se "
"realicen solicitudes de prueba contra la aplicación."

#: ../../testing.rst:75
msgid ""
"Because SQLite3 is filesystem-based, we can easily use the :mod:`tempfile` "
"module to create a temporary database and initialize it. The :func:`~tempfile."
"mkstemp` function does two things for us: it returns a low-level file handle "
"and a random file name, the latter we use as database name.  We just have to "
"keep the `db_fd` around so that we can use the :func:`os.close` function to "
"close the file."
msgstr ""
"Como SQLite3 está basado en el sistema de ficheros, podemos utilizar "
"fácilmente el módulo :mod:`tempfile` para crear una base de datos temporal e "
"inicializarla. La función :func:`~tempfile.mkstemp` hace dos cosas por "
"nosotros: devuelve un manejador de archivo de bajo nivel y un nombre de "
"archivo aleatorio, este último lo utilizamos como nombre de la base de datos. "
"Sólo tenemos que mantener el `db_fd` para poder utilizar la función :func:`os."
"close` para cerrar el archivo."

#: ../../testing.rst:82
msgid ""
"To delete the database after the test, the fixture closes the file and removes "
"it from the filesystem."
msgstr ""
"Para eliminar la base de datos después de la prueba, el fixture cierra el "
"archivo y lo elimina del sistema de archivos."

#: ../../testing.rst:85
msgid "If we now run the test suite, we should see the following output::"
msgstr ""
"Si ahora ejecutamos el conjunto de pruebas, deberíamos ver la siguiente "
"salida::"

#: ../../testing.rst:95
msgid ""
"Even though it did not run any actual tests, we already know that our "
"``flaskr`` application is syntactically valid, otherwise the import would have "
"died with an exception."
msgstr ""
"Aunque no ha ejecutado ninguna prueba real, ya sabemos que nuestra aplicación "
"``flaskr`` es sintácticamente válida, de lo contrario la importación habría "
"muerto con una excepción."

#: ../../testing.rst:103
msgid "The First Test"
msgstr "La primera prueba"

#: ../../testing.rst:105
msgid ""
"Now it's time to start testing the functionality of the application. Let's "
"check that the application shows \"No entries here so far\" if we access the "
"root of the application (``/``).  To do this, we add a new test function to :"
"file:`test_flaskr.py`, like this::"
msgstr ""
"Ahora es el momento de empezar a probar la funcionalidad de la aplicación. "
"Vamos a comprobar que la aplicación muestra \"No hay entradas aquí hasta ahora"
"\" si accedemos a la raíz de la aplicación (``/``).  Para ello, añadimos una "
"nueva función de prueba a :file:`test_flaskr.py`, así::"

#: ../../testing.rst:116
msgid ""
"Notice that our test functions begin with the word `test`; this allows "
"`pytest`_ to automatically identify the function as a test to run."
msgstr ""
"Observe que nuestras funciones de prueba comienzan con la palabra `test`; esto "
"permite a `pytest`_ identificar automáticamente la función como una prueba a "
"ejecutar."

#: ../../testing.rst:119
msgid ""
"By using ``client.get`` we can send an HTTP ``GET`` request to the application "
"with the given path.  The return value will be a :class:`~flask.Flask."
"response_class` object. We can now use the :attr:`~werkzeug.wrappers.Response."
"data` attribute to inspect the return value (as string) from the application. "
"In this case, we ensure that ``'No entries here so far'`` is part of the "
"output."
msgstr ""
"Usando ``client.get`` podemos enviar una petición HTTP ``GET`` a la aplicación "
"con la ruta dada.  El valor de retorno será un objeto :class:`~flask.Flask."
"response_class`. Ahora podemos utilizar el atributo :attr:`~werkzeug.wrappers."
"Response.data` para inspeccionar el valor de retorno (como cadena) de la "
"aplicación. En este caso, nos aseguramos de que ``No hay entradas aquí hasta "
"ahora`` es parte de la salida."

#: ../../testing.rst:127
msgid "Run it again and you should see one passing test::"
msgstr "Ejecútelo de nuevo y debería ver una prueba que pasa::"

#: ../../testing.rst:140
msgid "Logging In and Out"
msgstr "Entrar y salir del sistema"

#: ../../testing.rst:142
msgid ""
"The majority of the functionality of our application is only available for the "
"administrative user, so we need a way to log our test client in and out of the "
"application.  To do this, we fire some requests to the login and logout pages "
"with the required form data (username and password).  And because the login "
"and logout pages redirect, we tell the client to `follow_redirects`."
msgstr ""
"La mayor parte de la funcionalidad de nuestra aplicación sólo está disponible "
"para el usuario administrativo, por lo que necesitamos una forma de iniciar y "
"cerrar la sesión de nuestro cliente de prueba en la aplicación. Para ello, "
"lanzamos algunas peticiones a las páginas de inicio y cierre de sesión con los "
"datos requeridos del formulario (nombre de usuario y contraseña). Y como las "
"páginas de login y logout redirigen, le decimos al cliente que "
"`follow_redirects`."

#: ../../testing.rst:148
msgid "Add the following two functions to your :file:`test_flaskr.py` file::"
msgstr "Añade las siguientes dos funciones a tu archivo :file:`test_flaskr.py`::"

#: ../../testing.rst:160
msgid ""
"Now we can easily test that logging in and out works and that it fails with "
"invalid credentials.  Add this new test function::"
msgstr ""
"Ahora podemos probar fácilmente que el inicio y el cierre de sesión funciona y "
"que falla con credenciales no válidas. Añade esta nueva función de prueba::"

#: ../../testing.rst:182
msgid "Test Adding Messages"
msgstr "Prueba de adición de mensajes"

#: ../../testing.rst:184
msgid ""
"We should also test that adding messages works.  Add a new test function like "
"this::"
msgstr ""
"También debemos probar que la adición de mensajes funciona. Añade una nueva "
"función de prueba como esta::"

#: ../../testing.rst:199
msgid ""
"Here we check that HTML is allowed in the text but not in the title, which is "
"the intended behavior."
msgstr ""
"Aquí comprobamos que el HTML está permitido en el texto pero no en el título, "
"que es el comportamiento previsto."

#: ../../testing.rst:202
msgid "Running that should now give us three passing tests::"
msgstr "La ejecución de esto debería darnos tres pruebas de aprobación::"

#: ../../testing.rst:218
msgid "Other Testing Tricks"
msgstr "Otros trucos de comprobación"

#: ../../testing.rst:220
msgid ""
"Besides using the test client as shown above, there is also the :meth:`~flask."
"Flask.test_request_context` method that can be used in combination with the "
"``with`` statement to activate a request context temporarily.  With this you "
"can access the :class:`~flask.request`, :class:`~flask.g` and :class:`~flask."
"session` objects like in view functions.  Here is a full example that "
"demonstrates this approach::"
msgstr ""
"Además de utilizar el cliente de prueba como se ha mostrado anteriormente, "
"también existe el método :meth:`~flask.Flask.test_request_context` que se "
"puede utilizar en combinación con la sentencia ``with`` para activar un "
"contexto de petición temporalmente. Con esto puedes acceder a los objetos :"
"class:`~flask.request`, :class:`~flask.g` y :class:`~flask.session` como en "
"las funciones de vista. Aquí hay un ejemplo completo que demuestra este "
"enfoque::"

#: ../../testing.rst:235
msgid "All the other objects that are context bound can be used in the same way."
msgstr ""
"Todos los demás objetos que están vinculados al contexto pueden ser utilizados "
"de la misma manera."

#: ../../testing.rst:238
msgid ""
"If you want to test your application with different configurations and there "
"does not seem to be a good way to do that, consider switching to application "
"factories (see :doc:`patterns/appfactories`)."
msgstr ""
"Si quieres probar tu aplicación con diferentes configuraciones y no parece "
"haber una buena manera de hacerlo, considera cambiar a las fábricas de "
"aplicaciones (ver :doc:`patterns/appfactories`)."

#: ../../testing.rst:242
msgid ""
"Note however that if you are using a test request context, the :meth:`~flask."
"Flask.before_request` and :meth:`~flask.Flask.after_request` functions are not "
"called automatically.  However :meth:`~flask.Flask.teardown_request` functions "
"are indeed executed when the test request context leaves the ``with`` block.  "
"If you do want the :meth:`~flask.Flask.before_request` functions to be called "
"as well, you need to call :meth:`~flask.Flask.preprocess_request` yourself::"
msgstr ""
"Tenga en cuenta, sin embargo, que si está utilizando un contexto de petición "
"de prueba, las funciones :meth:`~flask.Flask.before_request` y :meth:`~flask."
"Flask.after_request` no se llaman automáticamente. Sin embargo, las funciones :"
"meth:`~flask.Flask.teardown_request` sí se ejecutan cuando el contexto de la "
"petición de prueba abandona el bloque ``with``. Si quieres que las funciones :"
"meth:`~flask.Flask.before_request` sean llamadas también, tienes que llamar tú "
"mismo a :meth:`~flask.Flask.preprocess_request`::"

#: ../../testing.rst:256
msgid ""
"This can be necessary to open database connections or something similar "
"depending on how your application was designed."
msgstr ""
"Esto puede ser necesario para abrir conexiones a bases de datos o algo similar "
"dependiendo de cómo se haya diseñado tu aplicación."

#: ../../testing.rst:259
msgid ""
"If you want to call the :meth:`~flask.Flask.after_request` functions you need "
"to call into :meth:`~flask.Flask.process_response` which however requires that "
"you pass it a response object::"
msgstr ""
"Si quieres llamar a las funciones :meth:`~flask.Flask.after_request` necesitas "
"llamar a :meth:`~flask.Flask.process_response` que sin embargo requiere que le "
"pases un objeto response::"

#: ../../testing.rst:270
msgid ""
"This in general is less useful because at that point you can directly start "
"using the test client."
msgstr ""
"Esto, en general, es menos útil porque en ese momento se puede empezar a "
"utilizar directamente el cliente de prueba."

#: ../../testing.rst:276
msgid "Faking Resources and Context"
msgstr "Falsificación de recursos y contexto"

#: ../../testing.rst:280
msgid ""
"A very common pattern is to store user authorization information and database "
"connections on the application context or the :attr:`flask.g` object.  The "
"general pattern for this is to put the object on there on first usage and then "
"to remove it on a teardown.  Imagine for instance this code to get the current "
"user::"
msgstr ""
"Un patrón muy común es almacenar la información de autorización del usuario y "
"las conexiones a la base de datos en el contexto de la aplicación o en el "
"objeto :attr:`flask.g`. El patrón general para esto es poner el objeto allí en "
"el primer uso y luego eliminarlo en un desmontaje. Imagina por ejemplo este "
"código para obtener el usuario actual::"

#: ../../testing.rst:293
msgid ""
"For a test it would be nice to override this user from the outside without "
"having to change some code.  This can be accomplished with hooking the :data:"
"`flask.appcontext_pushed` signal::"
msgstr ""
"Para una prueba sería bueno anular este usuario desde el exterior sin tener "
"que cambiar algo de código. Esto se puede lograr con el enganche de la señal :"
"data:`flask.appcontext_pushed`::"

#: ../../testing.rst:307
msgid "And then to use it::"
msgstr "Y luego a usarlo::"

#: ../../testing.rst:323
msgid "Keeping the Context Around"
msgstr "Mantener el contexto alrededor"

#: ../../testing.rst:327
msgid ""
"Sometimes it is helpful to trigger a regular request but still keep the "
"context around for a little longer so that additional introspection can "
"happen.  With Flask 0.4 this is possible by using the :meth:`~flask.Flask."
"test_client` with a ``with`` block::"
msgstr ""
"A veces es útil lanzar una petición regular pero mantener el contexto durante "
"un poco más de tiempo para que pueda ocurrir una introspección adicional. Con "
"Flask 0.4 esto es posible utilizando el :meth:`~flask.Flask.test_client` con "
"un bloque ``with``::"

#: ../../testing.rst:338
msgid ""
"If you were to use just the :meth:`~flask.Flask.test_client` without the "
"``with`` block, the ``assert`` would fail with an error because `request` is "
"no longer available (because you are trying to use it outside of the actual "
"request)."
msgstr ""
"Si se usara sólo el :meth:`~flask.Flask.test_client` sin el bloque ``with``, "
"el ``assert`` fallaría con un error porque `request` ya no está disponible "
"(porque se está intentando usar fuera de la petición real)."

#: ../../testing.rst:345
msgid "Accessing and Modifying Sessions"
msgstr "Acceso y modificación de las sesiones"

#: ../../testing.rst:349
msgid ""
"Sometimes it can be very helpful to access or modify the sessions from the "
"test client.  Generally there are two ways for this.  If you just want to "
"ensure that a session has certain keys set to certain values you can just keep "
"the context around and access :data:`flask.session`::"
msgstr ""
"A veces puede ser muy útil acceder o modificar las sesiones desde el cliente "
"de prueba.  Generalmente hay dos formas de hacerlo. Si sólo quieres asegurarte "
"de que una sesión tiene ciertas claves establecidas a ciertos valores puedes "
"simplemente mantener el contexto alrededor y acceder a :data:`flask.session`::"

#: ../../testing.rst:358
msgid ""
"This however does not make it possible to also modify the session or to access "
"the session before a request was fired.  Starting with Flask 0.8 we provide a "
"so called “session transaction” which simulates the appropriate calls to open "
"a session in the context of the test client and to modify it. At the end of "
"the transaction the session is stored and ready to be used by the test client. "
"This works independently of the session backend used::"
msgstr ""
"Sin embargo, esto no permite modificar también la sesión o acceder a ella "
"antes de que se dispare una petición. A partir de Flask 0.8 proporcionamos una "
"“transacción de sesión” que simula las llamadas apropiadas para abrir una "
"sesión en el contexto del cliente de prueba y para modificarla. Al final de la "
"transacción, la sesión se almacena y está lista para ser utilizada por el "
"cliente de prueba. Esto funciona independientemente del backend de sesión "
"utilizado:"

#: ../../testing.rst:372
msgid ""
"Note that in this case you have to use the ``sess`` object instead of the :"
"data:`flask.session` proxy.  The object however itself will provide the same "
"interface."
msgstr ""
"Tenga en cuenta que en este caso tiene que utilizar el objeto ``sess`` en "
"lugar del proxy :data:`flask.session``. Sin embargo, el objeto en sí mismo "
"proporcionará la misma interfaz."

#: ../../testing.rst:378
msgid "Testing JSON APIs"
msgstr "Prueba de las APIs JSON"

#: ../../testing.rst:382
msgid ""
"Flask has great support for JSON, and is a popular choice for building JSON "
"APIs. Making requests with JSON data and examining JSON data in responses is "
"very convenient::"
msgstr ""
"Flask tiene un gran soporte para JSON, y es una opción popular para construir "
"APIs JSON. Hacer peticiones con datos JSON y examinar los datos JSON en las "
"respuestas es muy conveniente::"

#: ../../testing.rst:402
msgid ""
"Passing the ``json`` argument in the test client methods sets the request data "
"to the JSON-serialized object and sets the content type to ``application/"
"json``. You can get the JSON data from the request or response with "
"``get_json``."
msgstr ""
"Al pasar el argumento ``json`` en los métodos del cliente de prueba, se "
"establecen los datos de la solicitud en el objeto serializado JSON y se "
"establece el tipo de contenido en ``application/json``. Puedes obtener los "
"datos JSON de la solicitud o la respuesta con ``get_json``."

#: ../../testing.rst:411
msgid "Testing CLI Commands"
msgstr "Prueba de los comandos de la CLI"

#: ../../testing.rst:413
msgid ""
"Click comes with `utilities for testing`_ your CLI commands. A :class:`~click."
"testing.CliRunner` runs commands in isolation and captures the output in a :"
"class:`~click.testing.Result` object."
msgstr ""
"Click viene con `utilidades para probar`_ sus comandos CLI. Un :class:`~click."
"testing.CliRunner` ejecuta los comandos de forma aislada y captura la salida "
"en un objeto :class:`~click.testing.Result`."

#: ../../testing.rst:417
msgid ""
"Flask provides :meth:`~flask.Flask.test_cli_runner` to create a :class:`~flask."
"testing.FlaskCliRunner` that passes the Flask app to the CLI automatically. "
"Use its :meth:`~flask.testing.FlaskCliRunner.invoke` method to call commands "
"in the same way they would be called from the command line. ::"
msgstr ""
"Flask proporciona :meth:`~flask.Flask.test_cli_runner` para crear una :class:"
"`~flask.testing.FlaskCliRunner` que pasa la aplicación Flask al CLI "
"automáticamente. Utiliza su método :meth:`~flask.testing.FlaskCliRunner."
"invoke` para llamar a los comandos de la misma manera que se llamarían desde "
"la línea de comandos. ::"

#: ../../testing.rst:441
msgid ""
"In the example above, invoking the command by name is useful because it "
"verifies that the command was correctly registered with the app."
msgstr ""
"En el ejemplo anterior, invocar el comando por su nombre es útil porque "
"verifica que el comando fue registrado correctamente con la aplicación."

#: ../../testing.rst:444
msgid ""
"If you want to test how your command parses parameters, without running the "
"command, use its :meth:`~click.BaseCommand.make_context` method. This is "
"useful for testing complex validation rules and custom types. ::"
msgstr ""
"Si quieres probar cómo tu comando analiza los parámetros, sin ejecutar el "
"comando, utiliza su método :meth:`~click.BaseCommand.make_context`. Esto es "
"útil para probar reglas de validación complejas y tipos personalizados. ::"
