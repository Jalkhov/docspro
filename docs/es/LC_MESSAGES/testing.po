# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010 Pallets
# This file is distributed under the same license as the Flask package.
# FIRST AUTHOR <pedrotorcattsoto@gmail.com>, 2021.
#
msgid ""
msgstr ""
"Project-Id-Version: Flask 2.0.x\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-05-27 07:20-0400\n"
"PO-Revision-Date: 2022-02-15 21:58-0400\n"
"Last-Translator: Pedro Torcatt <pedrotorcattsoto@gmail.com>\n"
"Language-Team: es_LA <pedrotorcattsoto@gmail.com>\n"
"Language: xd\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Generated-By: Babel 2.9.1\n"
"X-Generator: Poedit 3.0\n"

#: ../../testing.rst:2
msgid "Testing Flask Applications"
msgstr "Prueba de aplicaciones Flask"

#: ../../testing.rst:4
msgid ""
"Flask provides utilities for testing an application. This documentation goes"
" over techniques for working with different parts of the application in "
"tests."
msgstr ""

#: ../../testing.rst:8
msgid "We will use the `pytest`_ framework to set up and run our tests."
msgstr ""

#: ../../testing.rst:16
#, python-format
msgid ""
"The :doc:`tutorial </tutorial/index>` goes over how to write tests for 100% "
"coverage of the sample Flaskr blog application. See :doc:`the tutorial on "
"tests </tutorial/tests>` for a detailed explanation of specific tests for an"
" application."
msgstr ""

#: ../../testing.rst:23
msgid "Identifying Tests"
msgstr ""

#: ../../testing.rst:25
msgid ""
"Tests are typically located in the ``tests`` folder. Tests are functions "
"that start with ``test_``, in Python modules that start with ``test_``. "
"Tests can also be further grouped in classes that start with ``Test``."
msgstr ""

#: ../../testing.rst:29
msgid ""
"It can be difficult to know what to test. Generally, try to test the code "
"that you write, not the code of libraries that you use, since they are "
"already tested. Try to extract complex behaviors as separate functions to "
"test individually."
msgstr ""

#: ../../testing.rst:36
msgid "Fixtures"
msgstr ""

#: ../../testing.rst:38
msgid ""
"Pytest *fixtures* allow writing pieces of code that are reusable across "
"tests. A simple fixture returns a value, but a fixture can also do setup, "
"yield a value, then do teardown. Fixtures for the application, test client, "
"and CLI runner are shown below, they can be placed in ``tests/conftest.py``."
msgstr ""

#: ../../testing.rst:44
msgid ""
"If you're using an :doc:`application factory </patterns/appfactories>`, "
"define an ``app`` fixture to create and configure an app instance. You can "
"add code before and after the ``yield`` to set up and tear down other "
"resources, such as creating and clearing a database."
msgstr ""

#: ../../testing.rst:50
msgid ""
"If you're not using a factory, you already have an app object you can import"
" and configure directly. You can still use an ``app`` fixture to set up and "
"tear down resources."
msgstr ""

#: ../../testing.rst:84
msgid "Sending Requests with the Test Client"
msgstr ""

#: ../../testing.rst:86
msgid ""
"The test client makes requests to the application without running a live "
"server. Flask's client extends :doc:`Werkzeug's client <werkzeug:test>`, see"
" those docs for additional information."
msgstr ""

#: ../../testing.rst:91
msgid ""
"The ``client`` has methods that match the common HTTP request methods, such "
"as ``client.get()`` and ``client.post()``. They take many arguments for "
"building the request; you can find the full documentation in "
":class:`~werkzeug.test.EnvironBuilder`. Typically you'll use ``path``, "
"``query_string``, ``headers``, and ``data`` or ``json``."
msgstr ""

#: ../../testing.rst:97
msgid ""
"To make a request, call the method the request should use with the path to "
"the route to test. A :class:`~werkzeug.test.TestResponse` is returned to "
"examine the response data. It has all the usual properties of a response "
"object. You'll usually look at ``response.data``, which is the bytes "
"returned by the view. If you want to use text, Werkzeug 2.1 provides "
"``response.text``, or use ``response.get_data(as_text=True)``."
msgstr ""

#: ../../testing.rst:111
msgid ""
"Pass a dict ``query_string={\"key\": \"value\", ...}`` to set arguments in "
"the query string (after the ``?`` in the URL). You can also pass a string if"
" you want to set a specific value directly."
msgstr ""

#: ../../testing.rst:115
msgid "Pass a dict to ``headers={}`` to set request headers."
msgstr ""

#: ../../testing.rst:117
msgid ""
"To send a request body in a POST or PUT request, pass a value to ``data``. "
"If raw bytes are passed, that exact body is used. Usually, you'll pass a "
"dict to set form data."
msgstr ""

#: ../../testing.rst:123
msgid "Form Data"
msgstr ""

#: ../../testing.rst:125
msgid ""
"To send form data, pass a dict to ``data``. The ``Content-Type`` header will"
" be set to ``multipart/form-data`` or ``application/x-www-form-urlencoded`` "
"automatically."
msgstr ""

#: ../../testing.rst:129
msgid ""
"If a value is a file object opened for reading bytes (``\"rb\"`` mode), it "
"will be treated as an uploaded file. To change the detected filename and "
"content type, pass a ``(file, filename, content_type)`` tuple. File objects "
"will be closed after making the request, so they do not need to use the "
"usual ``with open() as f:`` pattern."
msgstr ""

#: ../../testing.rst:135
msgid ""
"It can be useful to store files in a ``tests/resources`` folder, then use "
"``pathlib.Path`` to get files relative to the current test file."
msgstr ""

#: ../../testing.rst:155
msgid "JSON Data"
msgstr ""

#: ../../testing.rst:157
msgid ""
"To send JSON data, pass an object to ``json``. The ``Content-Type`` header "
"will be set to ``application/json`` automatically."
msgstr ""

#: ../../testing.rst:160
msgid ""
"Similarly, if the response contains JSON data, the ``response.json`` "
"attribute will contain the deserialized object."
msgstr ""

#: ../../testing.rst:182
msgid "Following Redirects"
msgstr ""

#: ../../testing.rst:184
msgid ""
"By default, the client does not make additional requests if the response is "
"a redirect. By passing ``follow_redirects=True`` to a request method, the "
"client will continue to make requests until a non-redirect response is "
"returned."
msgstr ""

#: ../../testing.rst:189
msgid ""
":attr:`TestResponse.history <werkzeug.test.TestResponse.history>` is a tuple"
" of the responses that led up to the final response. Each response has a "
":attr:`~werkzeug.test.TestResponse.request` attribute which records the "
"request that produced that response."
msgstr ""

#: ../../testing.rst:205
#, fuzzy
msgid "Accessing and Modifying the Session"
msgstr "Acceso y modificación de las sesiones"

#: ../../testing.rst:207
msgid ""
"To access Flask's context variables, mainly :data:`~flask.session`, use the "
"client in a ``with`` statement. The app and request context will remain "
"active *after* making a request, until the ``with`` block ends."
msgstr ""

#: ../../testing.rst:224
msgid ""
"If you want to access or set a value in the session *before* making a "
"request, use the client's "
":meth:`~flask.testing.FlaskClient.session_transaction` method in a ``with`` "
"statement. It returns a session object, and will save the session once the "
"block ends."
msgstr ""

#: ../../testing.rst:248
msgid "Running Commands with the CLI Runner"
msgstr ""

#: ../../testing.rst:250
msgid ""
"Flask provides :meth:`~flask.Flask.test_cli_runner` to create a "
":class:`~flask.testing.FlaskCliRunner`, which runs CLI commands in isolation"
" and captures the output in a :class:`~click.testing.Result` object. Flask's"
" runner extends :doc:`Click's runner <click:testing>`, see those docs for "
"additional information."
msgstr ""

#: ../../testing.rst:256
msgid ""
"Use the runner's :meth:`~flask.testing.FlaskCliRunner.invoke` method to call"
" commands in the same way they would be called with the ``flask`` command "
"from the command line."
msgstr ""

#: ../../testing.rst:278
msgid "Tests that depend on an Active Context"
msgstr ""

#: ../../testing.rst:280
msgid ""
"You may have functions that are called from views or commands, that expect "
"an active :doc:`application context </appcontext>` or :doc:`request context"
"  </reqcontext>` because they access ``request``, ``session``, or "
"``current_app``. Rather than testing them by making a request or invoking "
"the command, you can create and activate a context directly."
msgstr ""

#: ../../testing.rst:287
msgid ""
"Use ``with app.app_context()`` to push an application context. For example, "
"database extensions usually require an active app context to make queries."
msgstr ""

#: ../../testing.rst:297
msgid ""
"Use ``with app.test_request_context()`` to push a request context. It takes "
"the same arguments as the test client's request methods."
msgstr ""

#: ../../testing.rst:311
msgid ""
"Creating a test request context doesn't run any of the Flask dispatching "
"code, so ``before_request`` functions are not called. If you need to call "
"these, usually it's better to make a full request instead. However, it's "
"possible to call them manually."
msgstr ""

#~ msgid "**Something that is untested is broken.**"
#~ msgstr "**Algo que no está probado está roto.**"

#~ msgid ""
#~ "The origin of this quote is unknown and while it is not entirely correct, it"
#~ " is also not far from the truth.  Untested applications make it hard to "
#~ "improve existing code and developers of untested applications tend to become"
#~ " pretty paranoid.  If an application has automated tests, you can safely "
#~ "make changes and instantly know if anything breaks."
#~ msgstr ""
#~ "El origen de esta cita es desconocido y, aunque no es del todo correcta, "
#~ "tampoco está lejos de la verdad. Las aplicaciones no probadas dificultan la "
#~ "mejora del código existente y los desarrolladores de aplicaciones no "
#~ "probadas tienden a volverse bastante paranoicos. Si una aplicación tiene "
#~ "pruebas automatizadas, puedes hacer cambios con seguridad y saber al "
#~ "instante si algo se rompe."

#~ msgid ""
#~ "Flask provides a way to test your application by exposing the Werkzeug test "
#~ ":class:`~werkzeug.test.Client` and handling the context locals for you. You "
#~ "can then use that with your favourite testing solution."
#~ msgstr ""
#~ "Flask proporciona una manera de probar su aplicación mediante la exposición "
#~ "de la prueba Werkzeug :class:`~werkzeug.test.Client` y el manejo de los "
#~ "locales de contexto para usted. Puedes utilizarlo con tu solución de pruebas"
#~ " favorita."

#~ msgid ""
#~ "In this documentation we will use the `pytest`_ package as the base "
#~ "framework for our tests. You can install it with ``pip``, like so::"
#~ msgstr ""
#~ "En esta documentación utilizaremos el paquete `pytest`_ como marco base para"
#~ " nuestras pruebas. Puedes instalarlo con ``pip``, así::"

#~ msgid "The Application"
#~ msgstr "La aplicación"

#~ msgid ""
#~ "First, we need an application to test; we will use the application from the "
#~ ":doc:`tutorial/index`. If you don't have that application yet, get the "
#~ "source code from :gh:`the examples <examples/tutorial>`."
#~ msgstr ""
#~ "En primer lugar, necesitamos una aplicación para probar; utilizaremos la "
#~ "aplicación del :doc:`tutorial/index`. Si aún no tienes esa aplicación, obtén"
#~ " el código fuente de :gh:`los ejemplos <examples/tutorial>`."

#~ msgid ""
#~ "So that we can import the module ``flaskr`` correctly, we need to run ``pip "
#~ "install -e .`` in the folder ``tutorial``."
#~ msgstr ""
#~ "Para poder importar el módulo ``flaskr`` correctamente, necesitamos ejecutar"
#~ " ``pip install -e .`` en la carpeta ``tutorial``."

#~ msgid "The Testing Skeleton"
#~ msgstr "El esqueleto de las pruebas"

#~ msgid ""
#~ "We begin by adding a tests directory under the application root.  Then "
#~ "create a Python file to store our tests (:file:`test_flaskr.py`). When we "
#~ "format the filename like ``test_*.py``, it will be auto-discoverable by "
#~ "pytest."
#~ msgstr ""
#~ "Comenzamos añadiendo un directorio de pruebas bajo la raíz de la aplicación."
#~ " Luego creamos un archivo Python para almacenar nuestras pruebas "
#~ "(:file:`prueba_flaskr.py`). Si formateamos el nombre del archivo como "
#~ "``test_*.py``, será autodescubierto por pytest."

#~ msgid ""
#~ "Next, we create a `pytest fixture`_ called :func:`client` that configures "
#~ "the application for testing and initializes a new database::"
#~ msgstr ""
#~ "A continuación, creamos un `pytest fixture`_ llamado :func:`client` que "
#~ "configura la aplicación para las pruebas e inicializa una nueva base de "
#~ "datos::"

#~ msgid ""
#~ "This client fixture will be called by each individual test.  It gives us a "
#~ "simple interface to the application, where we can trigger test requests to "
#~ "the application.  The client will also keep track of cookies for us."
#~ msgstr ""
#~ "Este fixture cliente será llamado por cada prueba individual. Nos da una "
#~ "interfaz simple a la aplicación, donde podemos lanzar peticiones de prueba a"
#~ " la aplicación. El cliente también mantendrá un seguimiento de las cookies "
#~ "para nosotros."

#~ msgid ""
#~ "During setup, the ``TESTING`` config flag is activated.  What this does is "
#~ "disable error catching during request handling, so that you get better error"
#~ " reports when performing test requests against the application."
#~ msgstr ""
#~ "Durante la configuración, se activa la bandera de configuración ``TESTING``."
#~ " Esto hace que se desactive la captura de errores durante la gestión de las "
#~ "solicitudes, de modo que se obtengan mejores informes de errores cuando se "
#~ "realicen solicitudes de prueba contra la aplicación."

#~ msgid ""
#~ "Because SQLite3 is filesystem-based, we can easily use the :mod:`tempfile` "
#~ "module to create a temporary database and initialize it. The "
#~ ":func:`~tempfile.mkstemp` function does two things for us: it returns a low-"
#~ "level file handle and a random file name, the latter we use as database "
#~ "name.  We just have to keep the `db_fd` around so that we can use the "
#~ ":func:`os.close` function to close the file."
#~ msgstr ""
#~ "Como SQLite3 está basado en el sistema de ficheros, podemos utilizar "
#~ "fácilmente el módulo :mod:`tempfile` para crear una base de datos temporal e"
#~ " inicializarla. La función :func:`~tempfile.mkstemp` hace dos cosas por "
#~ "nosotros: devuelve un manejador de archivo de bajo nivel y un nombre de "
#~ "archivo aleatorio, este último lo utilizamos como nombre de la base de "
#~ "datos. Sólo tenemos que mantener el `db_fd` para poder utilizar la función "
#~ ":func:`os.close` para cerrar el archivo."

#~ msgid ""
#~ "To delete the database after the test, the fixture closes the file and "
#~ "removes it from the filesystem."
#~ msgstr ""
#~ "Para eliminar la base de datos después de la prueba, el fixture cierra el "
#~ "archivo y lo elimina del sistema de archivos."

#~ msgid "If we now run the test suite, we should see the following output::"
#~ msgstr ""
#~ "Si ahora ejecutamos el conjunto de pruebas, deberíamos ver la siguiente "
#~ "salida::"

#~ msgid ""
#~ "Even though it did not run any actual tests, we already know that our "
#~ "``flaskr`` application is syntactically valid, otherwise the import would "
#~ "have died with an exception."
#~ msgstr ""
#~ "Aunque no ha ejecutado ninguna prueba real, ya sabemos que nuestra "
#~ "aplicación ``flaskr`` es sintácticamente válida, de lo contrario la "
#~ "importación habría muerto con una excepción."

#~ msgid "The First Test"
#~ msgstr "La primera prueba"

#~ msgid ""
#~ "Now it's time to start testing the functionality of the application. Let's "
#~ "check that the application shows \"No entries here so far\" if we access the"
#~ " root of the application (``/``).  To do this, we add a new test function to"
#~ " :file:`test_flaskr.py`, like this::"
#~ msgstr ""
#~ "Ahora es el momento de empezar a probar la funcionalidad de la aplicación. "
#~ "Vamos a comprobar que la aplicación muestra \"No hay entradas aquí hasta "
#~ "ahora\" si accedemos a la raíz de la aplicación (``/``).  Para ello, "
#~ "añadimos una nueva función de prueba a :file:`test_flaskr.py`, así::"

#~ msgid ""
#~ "Notice that our test functions begin with the word `test`; this allows "
#~ "`pytest`_ to automatically identify the function as a test to run."
#~ msgstr ""
#~ "Observe que nuestras funciones de prueba comienzan con la palabra `test`; "
#~ "esto permite a `pytest`_ identificar automáticamente la función como una "
#~ "prueba a ejecutar."

#~ msgid ""
#~ "By using ``client.get`` we can send an HTTP ``GET`` request to the "
#~ "application with the given path.  The return value will be a "
#~ ":class:`~flask.Flask.response_class` object. We can now use the "
#~ ":attr:`~werkzeug.wrappers.Response.data` attribute to inspect the return "
#~ "value (as string) from the application. In this case, we ensure that ``'No "
#~ "entries here so far'`` is part of the output."
#~ msgstr ""
#~ "Usando ``client.get`` podemos enviar una petición HTTP ``GET`` a la "
#~ "aplicación con la ruta dada.  El valor de retorno será un objeto "
#~ ":class:`~flask.Flask.response_class`. Ahora podemos utilizar el atributo "
#~ ":attr:`~werkzeug.wrappers.Response.data` para inspeccionar el valor de "
#~ "retorno (como cadena) de la aplicación. En este caso, nos aseguramos de que "
#~ "``No hay entradas aquí hasta ahora`` es parte de la salida."

#~ msgid "Run it again and you should see one passing test::"
#~ msgstr "Ejecútelo de nuevo y debería ver una prueba que pasa::"

#~ msgid "Logging In and Out"
#~ msgstr "Entrar y salir del sistema"

#~ msgid ""
#~ "The majority of the functionality of our application is only available for "
#~ "the administrative user, so we need a way to log our test client in and out "
#~ "of the application.  To do this, we fire some requests to the login and "
#~ "logout pages with the required form data (username and password).  And "
#~ "because the login and logout pages redirect, we tell the client to "
#~ "`follow_redirects`."
#~ msgstr ""
#~ "La mayor parte de la funcionalidad de nuestra aplicación sólo está "
#~ "disponible para el usuario administrativo, por lo que necesitamos una forma "
#~ "de iniciar y cerrar la sesión de nuestro cliente de prueba en la aplicación."
#~ " Para ello, lanzamos algunas peticiones a las páginas de inicio y cierre de "
#~ "sesión con los datos requeridos del formulario (nombre de usuario y "
#~ "contraseña). Y como las páginas de login y logout redirigen, le decimos al "
#~ "cliente que `follow_redirects`."

#~ msgid "Add the following two functions to your :file:`test_flaskr.py` file::"
#~ msgstr ""
#~ "Añade las siguientes dos funciones a tu archivo :file:`test_flaskr.py`::"

#~ msgid ""
#~ "Now we can easily test that logging in and out works and that it fails with "
#~ "invalid credentials.  Add this new test function::"
#~ msgstr ""
#~ "Ahora podemos probar fácilmente que el inicio y el cierre de sesión funciona"
#~ " y que falla con credenciales no válidas. Añade esta nueva función de "
#~ "prueba::"

#~ msgid "Test Adding Messages"
#~ msgstr "Prueba de adición de mensajes"

#~ msgid ""
#~ "We should also test that adding messages works.  Add a new test function "
#~ "like this::"
#~ msgstr ""
#~ "También debemos probar que la adición de mensajes funciona. Añade una nueva "
#~ "función de prueba como esta::"

#~ msgid ""
#~ "Here we check that HTML is allowed in the text but not in the title, which "
#~ "is the intended behavior."
#~ msgstr ""
#~ "Aquí comprobamos que el HTML está permitido en el texto pero no en el "
#~ "título, que es el comportamiento previsto."

#~ msgid "Running that should now give us three passing tests::"
#~ msgstr "La ejecución de esto debería darnos tres pruebas de aprobación::"

#~ msgid "Other Testing Tricks"
#~ msgstr "Otros trucos de comprobación"

#~ msgid ""
#~ "Besides using the test client as shown above, there is also the "
#~ ":meth:`~flask.Flask.test_request_context` method that can be used in "
#~ "combination with the ``with`` statement to activate a request context "
#~ "temporarily.  With this you can access the :class:`~flask.request`, "
#~ ":class:`~flask.g` and :class:`~flask.session` objects like in view "
#~ "functions.  Here is a full example that demonstrates this approach::"
#~ msgstr ""
#~ "Además de utilizar el cliente de prueba como se ha mostrado anteriormente, "
#~ "también existe el método :meth:`~flask.Flask.test_request_context` que se "
#~ "puede utilizar en combinación con la sentencia ``with`` para activar un "
#~ "contexto de petición temporalmente. Con esto puedes acceder a los objetos "
#~ ":class:`~flask.request`, :class:`~flask.g` y :class:`~flask.session` como en"
#~ " las funciones de vista. Aquí hay un ejemplo completo que demuestra este "
#~ "enfoque::"

#~ msgid ""
#~ "All the other objects that are context bound can be used in the same way."
#~ msgstr ""
#~ "Todos los demás objetos que están vinculados al contexto pueden ser "
#~ "utilizados de la misma manera."

#~ msgid ""
#~ "If you want to test your application with different configurations and there"
#~ " does not seem to be a good way to do that, consider switching to "
#~ "application factories (see :doc:`patterns/appfactories`)."
#~ msgstr ""
#~ "Si quieres probar tu aplicación con diferentes configuraciones y no parece "
#~ "haber una buena manera de hacerlo, considera cambiar a las fábricas de "
#~ "aplicaciones (ver :doc:`patterns/appfactories`)."

#~ msgid ""
#~ "Note however that if you are using a test request context, the "
#~ ":meth:`~flask.Flask.before_request` and :meth:`~flask.Flask.after_request` "
#~ "functions are not called automatically.  However "
#~ ":meth:`~flask.Flask.teardown_request` functions are indeed executed when the"
#~ " test request context leaves the ``with`` block.  If you do want the "
#~ ":meth:`~flask.Flask.before_request` functions to be called as well, you need"
#~ " to call :meth:`~flask.Flask.preprocess_request` yourself::"
#~ msgstr ""
#~ "Tenga en cuenta, sin embargo, que si está utilizando un contexto de petición"
#~ " de prueba, las funciones :meth:`~flask.Flask.before_request` y "
#~ ":meth:`~flask.Flask.after_request` no se llaman automáticamente. Sin "
#~ "embargo, las funciones :meth:`~flask.Flask.teardown_request` sí se ejecutan "
#~ "cuando el contexto de la petición de prueba abandona el bloque ``with``. Si "
#~ "quieres que las funciones :meth:`~flask.Flask.before_request` sean llamadas "
#~ "también, tienes que llamar tú mismo a "
#~ ":meth:`~flask.Flask.preprocess_request`::"

#~ msgid ""
#~ "This can be necessary to open database connections or something similar "
#~ "depending on how your application was designed."
#~ msgstr ""
#~ "Esto puede ser necesario para abrir conexiones a bases de datos o algo "
#~ "similar dependiendo de cómo se haya diseñado tu aplicación."

#~ msgid ""
#~ "If you want to call the :meth:`~flask.Flask.after_request` functions you "
#~ "need to call into :meth:`~flask.Flask.process_response` which however "
#~ "requires that you pass it a response object::"
#~ msgstr ""
#~ "Si quieres llamar a las funciones :meth:`~flask.Flask.after_request` "
#~ "necesitas llamar a :meth:`~flask.Flask.process_response` que sin embargo "
#~ "requiere que le pases un objeto response::"

#~ msgid ""
#~ "This in general is less useful because at that point you can directly start "
#~ "using the test client."
#~ msgstr ""
#~ "Esto, en general, es menos útil porque en ese momento se puede empezar a "
#~ "utilizar directamente el cliente de prueba."

#~ msgid "Faking Resources and Context"
#~ msgstr "Falsificación de recursos y contexto"

#~ msgid ""
#~ "A very common pattern is to store user authorization information and "
#~ "database connections on the application context or the :attr:`flask.g` "
#~ "object.  The general pattern for this is to put the object on there on first"
#~ " usage and then to remove it on a teardown.  Imagine for instance this code "
#~ "to get the current user::"
#~ msgstr ""
#~ "Un patrón muy común es almacenar la información de autorización del usuario "
#~ "y las conexiones a la base de datos en el contexto de la aplicación o en el "
#~ "objeto :attr:`flask.g`. El patrón general para esto es poner el objeto allí "
#~ "en el primer uso y luego eliminarlo en un desmontaje. Imagina por ejemplo "
#~ "este código para obtener el usuario actual::"

#~ msgid ""
#~ "For a test it would be nice to override this user from the outside without "
#~ "having to change some code.  This can be accomplished with hooking the "
#~ ":data:`flask.appcontext_pushed` signal::"
#~ msgstr ""
#~ "Para una prueba sería bueno anular este usuario desde el exterior sin tener "
#~ "que cambiar algo de código. Esto se puede lograr con el enganche de la señal"
#~ " :data:`flask.appcontext_pushed`::"

#~ msgid "And then to use it::"
#~ msgstr "Y luego a usarlo::"

#~ msgid "Keeping the Context Around"
#~ msgstr "Mantener el contexto alrededor"

#~ msgid ""
#~ "Sometimes it is helpful to trigger a regular request but still keep the "
#~ "context around for a little longer so that additional introspection can "
#~ "happen.  With Flask 0.4 this is possible by using the "
#~ ":meth:`~flask.Flask.test_client` with a ``with`` block::"
#~ msgstr ""
#~ "A veces es útil lanzar una petición regular pero mantener el contexto "
#~ "durante un poco más de tiempo para que pueda ocurrir una introspección "
#~ "adicional. Con Flask 0.4 esto es posible utilizando el "
#~ ":meth:`~flask.Flask.test_client` con un bloque ``with``::"

#~ msgid ""
#~ "If you were to use just the :meth:`~flask.Flask.test_client` without the "
#~ "``with`` block, the ``assert`` would fail with an error because `request` is"
#~ " no longer available (because you are trying to use it outside of the actual"
#~ " request)."
#~ msgstr ""
#~ "Si se usara sólo el :meth:`~flask.Flask.test_client` sin el bloque ``with``,"
#~ " el ``assert`` fallaría con un error porque `request` ya no está disponible "
#~ "(porque se está intentando usar fuera de la petición real)."

#~ msgid ""
#~ "Sometimes it can be very helpful to access or modify the sessions from the "
#~ "test client.  Generally there are two ways for this.  If you just want to "
#~ "ensure that a session has certain keys set to certain values you can just "
#~ "keep the context around and access :data:`flask.session`::"
#~ msgstr ""
#~ "A veces puede ser muy útil acceder o modificar las sesiones desde el cliente"
#~ " de prueba.  Generalmente hay dos formas de hacerlo. Si sólo quieres "
#~ "asegurarte de que una sesión tiene ciertas claves establecidas a ciertos "
#~ "valores puedes simplemente mantener el contexto alrededor y acceder a "
#~ ":data:`flask.session`::"

#~ msgid ""
#~ "This however does not make it possible to also modify the session or to "
#~ "access the session before a request was fired.  Starting with Flask 0.8 we "
#~ "provide a so called “session transaction” which simulates the appropriate "
#~ "calls to open a session in the context of the test client and to modify it. "
#~ "At the end of the transaction the session is stored and ready to be used by "
#~ "the test client. This works independently of the session backend used::"
#~ msgstr ""
#~ "Sin embargo, esto no permite modificar también la sesión o acceder a ella "
#~ "antes de que se dispare una petición. A partir de Flask 0.8 proporcionamos "
#~ "una “transacción de sesión” que simula las llamadas apropiadas para abrir "
#~ "una sesión en el contexto del cliente de prueba y para modificarla. Al final"
#~ " de la transacción, la sesión se almacena y está lista para ser utilizada "
#~ "por el cliente de prueba. Esto funciona independientemente del backend de "
#~ "sesión utilizado:"

#~ msgid ""
#~ "Note that in this case you have to use the ``sess`` object instead of the "
#~ ":data:`flask.session` proxy.  The object however itself will provide the "
#~ "same interface."
#~ msgstr ""
#~ "Tenga en cuenta que en este caso tiene que utilizar el objeto ``sess`` en "
#~ "lugar del proxy :data:`flask.session``. Sin embargo, el objeto en sí mismo "
#~ "proporcionará la misma interfaz."

#~ msgid "Testing JSON APIs"
#~ msgstr "Prueba de las APIs JSON"

#~ msgid ""
#~ "Flask has great support for JSON, and is a popular choice for building JSON "
#~ "APIs. Making requests with JSON data and examining JSON data in responses is"
#~ " very convenient::"
#~ msgstr ""
#~ "Flask tiene un gran soporte para JSON, y es una opción popular para "
#~ "construir APIs JSON. Hacer peticiones con datos JSON y examinar los datos "
#~ "JSON en las respuestas es muy conveniente::"

#~ msgid ""
#~ "Passing the ``json`` argument in the test client methods sets the request "
#~ "data to the JSON-serialized object and sets the content type to "
#~ "``application/json``. You can get the JSON data from the request or response"
#~ " with ``get_json``."
#~ msgstr ""
#~ "Al pasar el argumento ``json`` en los métodos del cliente de prueba, se "
#~ "establecen los datos de la solicitud en el objeto serializado JSON y se "
#~ "establece el tipo de contenido en ``application/json``. Puedes obtener los "
#~ "datos JSON de la solicitud o la respuesta con ``get_json``."

#~ msgid "Testing CLI Commands"
#~ msgstr "Prueba de los comandos de la CLI"

#~ msgid ""
#~ "Click comes with `utilities for testing`_ your CLI commands. A "
#~ ":class:`~click.testing.CliRunner` runs commands in isolation and captures "
#~ "the output in a :class:`~click.testing.Result` object."
#~ msgstr ""
#~ "Click viene con `utilidades para probar`_ sus comandos CLI. Un "
#~ ":class:`~click.testing.CliRunner` ejecuta los comandos de forma aislada y "
#~ "captura la salida en un objeto :class:`~click.testing.Result`."

#~ msgid ""
#~ "Flask provides :meth:`~flask.Flask.test_cli_runner` to create a "
#~ ":class:`~flask.testing.FlaskCliRunner` that passes the Flask app to the CLI "
#~ "automatically. Use its :meth:`~flask.testing.FlaskCliRunner.invoke` method "
#~ "to call commands in the same way they would be called from the command line."
#~ " ::"
#~ msgstr ""
#~ "Flask proporciona :meth:`~flask.Flask.test_cli_runner` para crear una "
#~ ":class:`~flask.testing.FlaskCliRunner` que pasa la aplicación Flask al CLI "
#~ "automáticamente. Utiliza su método "
#~ ":meth:`~flask.testing.FlaskCliRunner.invoke` para llamar a los comandos de "
#~ "la misma manera que se llamarían desde la línea de comandos. ::"

#~ msgid ""
#~ "In the example above, invoking the command by name is useful because it "
#~ "verifies that the command was correctly registered with the app."
#~ msgstr ""
#~ "En el ejemplo anterior, invocar el comando por su nombre es útil porque "
#~ "verifica que el comando fue registrado correctamente con la aplicación."

#~ msgid ""
#~ "If you want to test how your command parses parameters, without running the "
#~ "command, use its :meth:`~click.BaseCommand.make_context` method. This is "
#~ "useful for testing complex validation rules and custom types. ::"
#~ msgstr ""
#~ "Si quieres probar cómo tu comando analiza los parámetros, sin ejecutar el "
#~ "comando, utiliza su método :meth:`~click.BaseCommand.make_context`. Esto es "
#~ "útil para probar reglas de validación complejas y tipos personalizados. ::"
