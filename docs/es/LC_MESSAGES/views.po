# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010 Pallets
# This file is distributed under the same license as the Flask package.
# FIRST AUTHOR <pedrotorcattsoto@gmail.com>, 2021.
#
msgid ""
msgstr ""
"Project-Id-Version: Flask 2.0.x\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-05-27 07:20-0400\n"
"PO-Revision-Date: 2022-02-15 21:58-0400\n"
"Language-Team: es_LA <pedrotorcattsoto@gmail.com>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"Last-Translator: Pedro Torcatt <pedrotorcattsoto@gmail.com>\n"
"Language: es\n"
"X-Generator: Poedit 3.0\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../views.rst:2
msgid "Pluggable Views"
msgstr "Vistas acoplables"

#: ../../views.rst:6
msgid ""
"Flask 0.7 introduces pluggable views inspired by the generic views from "
"Django which are based on classes instead of functions.  The main "
"intention is that you can replace parts of the implementations and this "
"way have customizable pluggable views."
msgstr ""
"Flask 0.7 introduce vistas acoplables inspiradas en las vistas genéricas "
"de Django que se basan en clases en lugar de funciones. La intención "
"principal es que puedas reemplazar partes de las implementaciones y de "
"esta manera tener vistas acoplables personalizables."

#: ../../views.rst:12
msgid "Basic Principle"
msgstr "Principio básico"

#: ../../views.rst:14
msgid ""
"Consider you have a function that loads a list of objects from the "
"database and renders into a template::"
msgstr ""
"Considere que tiene una función que carga una lista de objetos de la "
"base de datos y los renderiza en una plantilla::"

#: ../../views.rst:22
msgid ""
"This is simple and flexible, but if you want to provide this view in a "
"generic fashion that can be adapted to other models and templates as "
"well you might want more flexibility.  This is where pluggable class-"
"based views come into place.  As the first step to convert this into a "
"class based view you would do this::"
msgstr ""
"Esto es simple y flexible, pero si quieres proporcionar esta vista de "
"forma genérica que pueda ser adaptada a otros modelos y plantillas "
"también podrías querer más flexibilidad. Aquí es donde entran en juego "
"las vistas basadas en clases acoplables. Como primer paso para convertir "
"esto en una vista basada en clases se haría lo siguiente::"

#: ../../views.rst:39
msgid ""
"As you can see what you have to do is to create a subclass of :class:"
"`flask.views.View` and implement :meth:`~flask.views.View."
"dispatch_request`.  Then we have to convert that class into an actual "
"view function by using the :meth:`~flask.views.View.as_view` class "
"method.  The string you pass to that function is the name of the "
"endpoint that view will then have.  But this by itself is not helpful, "
"so let's refactor the code a bit::"
msgstr ""
"Como puedes ver lo que tienes que hacer es crear una subclase de :class:"
"`flask.views.View` e implementar :meth:`~flask.views.View."
"dispatch_request`. Luego tenemos que convertir esa clase en una función "
"de vista real utilizando el método de clase :meth:`~flask.views.View."
"as_view`.  La cadena que se pasa a esa función es el nombre del endpoint "
"que tendrá esa vista. Pero esto por sí mismo no es útil, así que vamos a "
"refactorizar el código un poco::"

#: ../../views.rst:70
msgid ""
"This of course is not that helpful for such a small example, but it's "
"good enough to explain the basic principle.  When you have a class-based "
"view the question comes up what ``self`` points to.  The way this works "
"is that whenever the request is dispatched a new instance of the class "
"is created and the :meth:`~flask.views.View.dispatch_request` method is "
"called with the parameters from the URL rule.  The class itself is "
"instantiated with the parameters passed to the :meth:`~flask.views.View."
"as_view` function. For instance you can write a class like this::"
msgstr ""
"Esto, por supuesto, no es tan útil para un ejemplo tan pequeño, pero es "
"suficiente para explicar el principio básico. Cuando se tiene una vista "
"basada en una clase surge la pregunta de a qué apunta ``self``. La forma "
"en que funciona es que cada vez que se despacha la petición se crea una "
"nueva instancia de la clase y se llama al método :meth:`~flask.views."
"View.dispatch_request` con los parámetros de la regla URL. La propia "
"clase se instanciará con los parámetros pasados a la función :meth:"
"`~flask.views.View.as_view`. Por ejemplo, puedes escribir una clase como "
"esta::"

#: ../../views.rst:85
msgid "And then you can register it like this::"
msgstr "Y luego puedes registrarlo así::"

#: ../../views.rst:91
msgid "Method Hints"
msgstr "Consejos sobre el método"

#: ../../views.rst:93
msgid ""
"Pluggable views are attached to the application like a regular function "
"by either using :func:`~flask.Flask.route` or better :meth:`~flask.Flask."
"add_url_rule`.  That however also means that you would have to provide "
"the names of the HTTP methods the view supports when you attach this.  "
"In order to move that information to the class you can provide a :attr:"
"`~flask.views.View.methods` attribute that has this information::"
msgstr ""
"Las vistas conectables se adjuntan a la aplicación como una función "
"normal utilizando :func:`~flask.Flask.route` o mejor :meth:`~flask.Flask."
"add_url_rule`. Sin embargo, eso también significa que tendrías que "
"proporcionar los nombres de los métodos HTTP que la vista soporta cuando "
"adjuntas esto. Para trasladar esa información a la clase puedes "
"proporcionar un atributo :attr:`~flask.views.View.methods` que tenga "
"esta información::"

#: ../../views.rst:112
msgid "Method Based Dispatching"
msgstr "Despacho basado en el método"

#: ../../views.rst:114
msgid ""
"For RESTful APIs it's especially helpful to execute a different function "
"for each HTTP method.  With the :class:`flask.views.MethodView` you can "
"easily do that.  Each HTTP method maps to a function with the same name "
"(just in lowercase)::"
msgstr ""
"Para las APIs RESTful es especialmente útil ejecutar una función "
"diferente para cada método HTTP. Con la :class:`flask.views.MethodView` "
"puedes hacerlo fácilmente. Cada método HTTP se asigna a una función con "
"el mismo nombre (sólo en minúsculas)::"

#: ../../views.rst:133
msgid ""
"That way you also don't have to provide the :attr:`~flask.views.View."
"methods` attribute.  It's automatically set based on the methods defined "
"in the class."
msgstr ""
"De esta manera tampoco tienes que proporcionar el atributo :attr:`~flask."
"views.View.methods`.  Se establece automáticamente en función de los "
"métodos definidos en la clase."

#: ../../views.rst:138
msgid "Decorating Views"
msgstr "Decorando vistas"

#: ../../views.rst:140
msgid ""
"Since the view class itself is not the view function that is added to "
"the routing system it does not make much sense to decorate the class "
"itself. Instead you either have to decorate the return value of :meth:"
"`~flask.views.View.as_view` by hand::"
msgstr ""
"Dado que la clase view en sí misma no es la función view que se añade al "
"sistema de enrutamiento, no tiene mucho sentido decorar la clase en sí "
"misma. En su lugar, hay que decorar a mano el valor de retorno de :meth:"
"`~flask.views.View.as_view`::"

#: ../../views.rst:156
msgid ""
"Starting with Flask 0.8 there is also an alternative way where you can "
"specify a list of decorators to apply in the class declaration::"
msgstr ""
"A partir de Flask 0.8 existe también una forma alternativa en la que se "
"puede especificar una lista de decoradores a aplicar en la declaración "
"de la clase::"

#: ../../views.rst:162
msgid ""
"Due to the implicit self from the caller's perspective you cannot use "
"regular view decorators on the individual methods of the view however, "
"keep this in mind."
msgstr ""
"Debido a que el self está implícito desde la perspectiva de la persona "
"que llama, no puedes usar decoradores de vista regulares en los métodos "
"individuales de la vista, sin embargo, tenlo en cuenta."

#: ../../views.rst:167
msgid "Method Views for APIs"
msgstr "Vistas de métodos para APIs"

#: ../../views.rst:169
msgid ""
"Web APIs are often working very closely with HTTP verbs so it makes a "
"lot of sense to implement such an API based on the :class:`~flask.views."
"MethodView`.  That said, you will notice that the API will require "
"different URL rules that go to the same method view most of the time.  "
"For instance consider that you are exposing a user object on the web:"
msgstr ""
"Las APIs de la web suelen trabajar muy estrechamente con los verbos HTTP "
"por lo que tiene mucho sentido implementar una API de este tipo basada "
"en la :class:`~flask.views.MethodView`. Dicho esto, te darás cuenta de "
"que la API requerirá diferentes reglas de URL que vayan a la misma vista "
"de método la mayoría de las veces. Por ejemplo, considera que estás "
"exponiendo un objeto de usuario en la web:"

#: ../../views.rst:177
msgid "URL"
msgstr ""

#: ../../views.rst:177
msgid "Method"
msgstr "Método"

#: ../../views.rst:177
msgid "Description"
msgstr "Descripción"

#: ../../views.rst:179 ../../views.rst:180
msgid "``/users/``"
msgstr ""

#: ../../views.rst:179 ../../views.rst:181
msgid "``GET``"
msgstr ""

#: ../../views.rst:179
msgid "Gives a list of all users"
msgstr "Da una lista de todos los usuarios"

#: ../../views.rst:180
msgid "``POST``"
msgstr ""

#: ../../views.rst:180
msgid "Creates a new user"
msgstr "Crea un nuevo usuario"

#: ../../views.rst:181 ../../views.rst:182 ../../views.rst:183
msgid "``/users/<id>``"
msgstr ""

#: ../../views.rst:181
msgid "Shows a single user"
msgstr "Muestra un solo usuario"

#: ../../views.rst:182
msgid "``PUT``"
msgstr ""

#: ../../views.rst:182
msgid "Updates a single user"
msgstr "Actualiza un solo usuario"

#: ../../views.rst:183
msgid "``DELETE``"
msgstr ""

#: ../../views.rst:183
msgid "Deletes a single user"
msgstr "Elimina un solo usuario"

#: ../../views.rst:186
msgid ""
"So how would you go about doing that with the :class:`~flask.views."
"MethodView`?  The trick is to take advantage of the fact that you can "
"provide multiple rules to the same view."
msgstr ""
"Entonces, ¿cómo hacer eso con la :class:`~flask.views.MethodView`? El "
"truco es aprovechar el hecho de que puedes proporcionar múltiples reglas "
"a la misma vista."

#: ../../views.rst:190
msgid "Let's assume for the moment the view would look like this::"
msgstr "Asumamos por el momento que la vista se vería así::"

#: ../../views.rst:214
msgid ""
"So how do we hook this up with the routing system?  By adding two rules "
"and explicitly mentioning the methods for each::"
msgstr ""
"Entonces, ¿cómo conectamos esto con el sistema de enrutamiento? "
"Añadiendo dos reglas y mencionando explícitamente los métodos de cada "
"una::"

#: ../../views.rst:224
msgid ""
"If you have a lot of APIs that look similar you can refactor that "
"registration code::"
msgstr ""
"Si tienes muchas APIs que se parecen puedes refactorizar ese código de "
"registro::"
