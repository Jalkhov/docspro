# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010 Pallets
# This file is distributed under the same license as the Flask package.
# FIRST AUTHOR <pedrotorcattsoto@gmail.com>, 2021.
#
msgid ""
msgstr ""
"Project-Id-Version: Flask 2.0.x\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-05-27 07:20-0400\n"
"PO-Revision-Date: 2022-02-15 21:58-0400\n"
"Last-Translator: Pedro Torcatt <pedrotorcattsoto@gmail.com>\n"
"Language-Team: es_LA <pedrotorcattsoto@gmail.com>\n"
"Language: xd\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Generated-By: Babel 2.9.1\n"
"X-Generator: Poedit 3.0\n"

#: ../../views.rst:2
msgid "Class-based Views"
msgstr ""

#: ../../views.rst:6
msgid ""
"This page introduces using the :class:`View` and :class:`MethodView` classes"
" to write class-based views."
msgstr ""

#: ../../views.rst:9
msgid ""
"A class-based view is a class that acts as a view function. Because it is a "
"class, different instances of the class can be created with different "
"arguments, to change the behavior of the view. This is also known as "
"generic, reusable, or pluggable views."
msgstr ""

#: ../../views.rst:14
msgid ""
"An example of where this is useful is defining a class that creates an API "
"based on the database model it is initialized with."
msgstr ""

#: ../../views.rst:17
msgid ""
"For more complex API behavior and customization, look into the various API "
"extensions for Flask."
msgstr ""

#: ../../views.rst:22
msgid "Basic Reusable View"
msgstr ""

#: ../../views.rst:24
msgid ""
"Let's walk through an example converting a view function to a view class. We"
" start with a view function that queries a list of users then renders a "
"template to show the list."
msgstr ""

#: ../../views.rst:35
msgid ""
"This works for the user model, but let's say you also had more models that "
"needed list pages. You'd need to write another view function for each model,"
" even though the only thing that would change is the model and template "
"name."
msgstr ""

#: ../../views.rst:40
msgid ""
"Instead, you can write a :class:`View` subclass that will query a model and "
"render a template. As the first step, we'll convert the view to a class "
"without any customization."
msgstr ""

#: ../../views.rst:55
msgid ""
"The :meth:`View.dispatch_request` method is the equivalent of the view "
"function. Calling :meth:`View.as_view` method will create a view function "
"that can be registered on the app with its :meth:`~flask.Flask.add_url_rule`"
" method. The first argument to ``as_view`` is the name to use to refer to "
"the view with :func:`~flask.url_for`."
msgstr ""

#: ../../views.rst:64
msgid ""
"You can't decorate the class with ``@app.route()`` the way you'd do with a "
"basic view function."
msgstr ""

#: ../../views.rst:67
msgid ""
"Next, we need to be able to register the same view class for different "
"models and templates, to make it more useful than the original function. The"
" class will take two arguments, the model and template, and store them on "
"``self``. Then ``dispatch_request`` can reference these instead of hard-"
"coded values."
msgstr ""

#: ../../views.rst:84
msgid ""
"Remember, we create the view function with ``View.as_view()`` instead of "
"creating the class directly. Any extra arguments passed to ``as_view`` are "
"then passed when creating the class. Now we can register the same view to "
"handle multiple models."
msgstr ""

#: ../../views.rst:102
msgid "URL Variables"
msgstr ""

#: ../../views.rst:104
msgid ""
"Any variables captured by the URL are passed as keyword arguments to the "
"``dispatch_request`` method, as they would be for a regular view function."
msgstr ""

#: ../../views.rst:123
msgid "View Lifetime and ``self``"
msgstr ""

#: ../../views.rst:125
msgid ""
"By default, a new instance of the view class is created every time a request"
" is handled. This means that it is safe to write other data to ``self`` "
"during the request, since the next request will not see it, unlike other "
"forms of global state."
msgstr ""

#: ../../views.rst:130
msgid ""
"However, if your view class needs to do a lot of complex initialization, "
"doing it for every request is unnecessary and can be inefficient. To avoid "
"this, set :attr:`View.init_every_request` to ``False``, which will only "
"create one instance of the class and use it for every request. In this case,"
" writing to ``self`` is not safe. If you need to store data during the "
"request, use :data:`~flask.g` instead."
msgstr ""

#: ../../views.rst:137
msgid ""
"In the ``ListView`` example, nothing writes to ``self`` during the request, "
"so it is more efficient to create a single instance."
msgstr ""

#: ../../views.rst:153
msgid ""
"Different instances will still be created each for each ``as_view`` call, "
"but not for each request to those views."
msgstr ""

#: ../../views.rst:158
msgid "View Decorators"
msgstr ""

#: ../../views.rst:160
msgid ""
"The view class itself is not the view function. View decorators need to be "
"applied to the view function returned by ``as_view``, not the class itself. "
"Set :attr:`View.decorators` to a list of decorators to apply."
msgstr ""

#: ../../views.rst:171
msgid ""
"If you didn't set ``decorators``, you could apply them manually instead. "
"This is equivalent to:"
msgstr ""

#: ../../views.rst:181
msgid ""
"Keep in mind that order matters. If you're used to ``@decorator`` style, "
"this is equivalent to:"
msgstr ""

#: ../../views.rst:194
msgid "Method Hints"
msgstr "Consejos sobre el método"

#: ../../views.rst:196
msgid ""
"A common pattern is to register a view with ``methods=[\"GET\", \"POST\"]``,"
" then check ``request.method == \"POST\"`` to decide what to do. Setting "
":attr:`View.methods` is equivalent to passing the list of methods to "
"``add_url_rule`` or ``route``."
msgstr ""

#: ../../views.rst:213
msgid ""
"This is equivalent to the following, except further subclasses can inherit "
"or change the methods."
msgstr ""

#: ../../views.rst:226
#, fuzzy
msgid "Method Dispatching and APIs"
msgstr "Despacho basado en el método"

#: ../../views.rst:228
msgid ""
"For APIs it can be helpful to use a different function for each HTTP method."
" :class:`MethodView` extends the basic :class:`View` to dispatch to "
"different methods of the class based on the request method. Each HTTP method"
" maps to a method of the class with the same (lowercase) name."
msgstr ""

#: ../../views.rst:233
msgid ""
":class:`MethodView` automatically sets :attr:`View.methods` based on the "
"methods defined by the class. It even knows how to handle subclasses that "
"override or define other methods."
msgstr ""

#: ../../views.rst:237
msgid ""
"We can make a generic ``ItemAPI`` class that provides get (detail), patch "
"(edit), and delete methods for a given model. A ``GroupAPI`` can provide get"
" (list) and post (create) methods."
msgstr ""

#: ../../views.rst:304
msgid "This produces the following views, a standard REST API!"
msgstr ""

#: ../../views.rst:307
msgid "URL"
msgstr "URL"

#: ../../views.rst:307
msgid "Method"
msgstr "Método"

#: ../../views.rst:307
msgid "Description"
msgstr "Descripción"

#: ../../views.rst:309 ../../views.rst:310
msgid "``/users/``"
msgstr "``/users/``"

#: ../../views.rst:309 ../../views.rst:311 ../../views.rst:314
#: ../../views.rst:316
msgid "``GET``"
msgstr "``GET``"

#: ../../views.rst:309
#, fuzzy
msgid "List all users"
msgstr "Da una lista de todos los usuarios"

#: ../../views.rst:310 ../../views.rst:315
msgid "``POST``"
msgstr "``POST``"

#: ../../views.rst:310
#, fuzzy
msgid "Create a new user"
msgstr "Crea un nuevo usuario"

#: ../../views.rst:311 ../../views.rst:312 ../../views.rst:313
msgid "``/users/<id>``"
msgstr "``/users/<id>``"

#: ../../views.rst:311
#, fuzzy
msgid "Show a single user"
msgstr "Muestra un solo usuario"

#: ../../views.rst:312 ../../views.rst:317
msgid "``PATCH``"
msgstr ""

#: ../../views.rst:312
#, fuzzy
msgid "Update a user"
msgstr "Actualiza un solo usuario"

#: ../../views.rst:313 ../../views.rst:318
msgid "``DELETE``"
msgstr "``DELETE``"

#: ../../views.rst:313
#, fuzzy
msgid "Delete a user"
msgstr "Elimina un solo usuario"

#: ../../views.rst:314 ../../views.rst:315
#, fuzzy
msgid "``/stories/``"
msgstr "``/users/``"

#: ../../views.rst:314
msgid "List all stories"
msgstr ""

#: ../../views.rst:315
#, fuzzy
msgid "Create a new story"
msgstr "Crea un nuevo usuario"

#: ../../views.rst:316 ../../views.rst:317 ../../views.rst:318
#, fuzzy
msgid "``/stories/<id>``"
msgstr "``/users/<id>``"

#: ../../views.rst:316
#, fuzzy
msgid "Show a single story"
msgstr "Muestra un solo usuario"

#: ../../views.rst:317
msgid "Update a story"
msgstr ""

#: ../../views.rst:318
msgid "Delete a story"
msgstr ""

#~ msgid "Pluggable Views"
#~ msgstr "Vistas acoplables"

#~ msgid ""
#~ "Flask 0.7 introduces pluggable views inspired by the generic views from "
#~ "Django which are based on classes instead of functions.  The main intention "
#~ "is that you can replace parts of the implementations and this way have "
#~ "customizable pluggable views."
#~ msgstr ""
#~ "Flask 0.7 introduce vistas acoplables inspiradas en las vistas genéricas de "
#~ "Django que se basan en clases en lugar de funciones. La intención principal "
#~ "es que puedas reemplazar partes de las implementaciones y de esta manera "
#~ "tener vistas acoplables personalizables."

#~ msgid "Basic Principle"
#~ msgstr "Principio básico"

#~ msgid ""
#~ "Consider you have a function that loads a list of objects from the database "
#~ "and renders into a template::"
#~ msgstr ""
#~ "Considere que tiene una función que carga una lista de objetos de la base de"
#~ " datos y los renderiza en una plantilla::"

#~ msgid ""
#~ "This is simple and flexible, but if you want to provide this view in a "
#~ "generic fashion that can be adapted to other models and templates as well "
#~ "you might want more flexibility.  This is where pluggable class-based views "
#~ "come into place.  As the first step to convert this into a class based view "
#~ "you would do this::"
#~ msgstr ""
#~ "Esto es simple y flexible, pero si quieres proporcionar esta vista de forma "
#~ "genérica que pueda ser adaptada a otros modelos y plantillas también podrías"
#~ " querer más flexibilidad. Aquí es donde entran en juego las vistas basadas "
#~ "en clases acoplables. Como primer paso para convertir esto en una vista "
#~ "basada en clases se haría lo siguiente::"

#~ msgid ""
#~ "As you can see what you have to do is to create a subclass of "
#~ ":class:`flask.views.View` and implement "
#~ ":meth:`~flask.views.View.dispatch_request`.  Then we have to convert that "
#~ "class into an actual view function by using the "
#~ ":meth:`~flask.views.View.as_view` class method.  The string you pass to that"
#~ " function is the name of the endpoint that view will then have.  But this by"
#~ " itself is not helpful, so let's refactor the code a bit::"
#~ msgstr ""
#~ "Como puedes ver lo que tienes que hacer es crear una subclase de "
#~ ":class:`flask.views.View` e implementar "
#~ ":meth:`~flask.views.View.dispatch_request`. Luego tenemos que convertir esa "
#~ "clase en una función de vista real utilizando el método de clase "
#~ ":meth:`~flask.views.View.as_view`.  La cadena que se pasa a esa función es "
#~ "el nombre del endpoint que tendrá esa vista. Pero esto por sí mismo no es "
#~ "útil, así que vamos a refactorizar el código un poco::"

#~ msgid ""
#~ "This of course is not that helpful for such a small example, but it's good "
#~ "enough to explain the basic principle.  When you have a class-based view the"
#~ " question comes up what ``self`` points to.  The way this works is that "
#~ "whenever the request is dispatched a new instance of the class is created "
#~ "and the :meth:`~flask.views.View.dispatch_request` method is called with the"
#~ " parameters from the URL rule.  The class itself is instantiated with the "
#~ "parameters passed to the :meth:`~flask.views.View.as_view` function. For "
#~ "instance you can write a class like this::"
#~ msgstr ""
#~ "Esto, por supuesto, no es tan útil para un ejemplo tan pequeño, pero es "
#~ "suficiente para explicar el principio básico. Cuando se tiene una vista "
#~ "basada en una clase surge la pregunta de a qué apunta ``self``. La forma en "
#~ "que funciona es que cada vez que se despacha la petición se crea una nueva "
#~ "instancia de la clase y se llama al método "
#~ ":meth:`~flask.views.View.dispatch_request` con los parámetros de la regla "
#~ "URL. La propia clase se instanciará con los parámetros pasados a la función "
#~ ":meth:`~flask.views.View.as_view`. Por ejemplo, puedes escribir una clase "
#~ "como esta::"

#~ msgid "And then you can register it like this::"
#~ msgstr "Y luego puedes registrarlo así::"

#~ msgid ""
#~ "Pluggable views are attached to the application like a regular function by "
#~ "either using :func:`~flask.Flask.route` or better "
#~ ":meth:`~flask.Flask.add_url_rule`.  That however also means that you would "
#~ "have to provide the names of the HTTP methods the view supports when you "
#~ "attach this.  In order to move that information to the class you can provide"
#~ " a :attr:`~flask.views.View.methods` attribute that has this information::"
#~ msgstr ""
#~ "Las vistas conectables se adjuntan a la aplicación como una función normal "
#~ "utilizando :func:`~flask.Flask.route` o mejor "
#~ ":meth:`~flask.Flask.add_url_rule`. Sin embargo, eso también significa que "
#~ "tendrías que proporcionar los nombres de los métodos HTTP que la vista "
#~ "soporta cuando adjuntas esto. Para trasladar esa información a la clase "
#~ "puedes proporcionar un atributo :attr:`~flask.views.View.methods` que tenga "
#~ "esta información::"

#~ msgid ""
#~ "For RESTful APIs it's especially helpful to execute a different function for"
#~ " each HTTP method.  With the :class:`flask.views.MethodView` you can easily "
#~ "do that.  Each HTTP method maps to a method of the class with the same name "
#~ "(just in lowercase)::"
#~ msgstr ""
#~ "Para las APIs RESTful es especialmente útil ejecutar una función diferente "
#~ "para cada método HTTP.  Con la :class:`flask.views.MethodView` puedes "
#~ "hacerlo fácilmente.  Cada método HTTP mapea a un método de la clase con el "
#~ "mismo nombre (sólo en minúsculas)::"

#~ msgid ""
#~ "That way you also don't have to provide the "
#~ ":attr:`~flask.views.View.methods` attribute.  It's automatically set based "
#~ "on the methods defined in the class."
#~ msgstr ""
#~ "De esta manera tampoco tienes que proporcionar el atributo "
#~ ":attr:`~flask.views.View.methods`.  Se establece automáticamente en función "
#~ "de los métodos definidos en la clase."

#~ msgid "Decorating Views"
#~ msgstr "Decorando vistas"

#~ msgid ""
#~ "Since the view class itself is not the view function that is added to the "
#~ "routing system it does not make much sense to decorate the class itself. "
#~ "Instead you either have to decorate the return value of "
#~ ":meth:`~flask.views.View.as_view` by hand::"
#~ msgstr ""
#~ "Dado que la clase view en sí misma no es la función view que se añade al "
#~ "sistema de enrutamiento, no tiene mucho sentido decorar la clase en sí "
#~ "misma. En su lugar, hay que decorar a mano el valor de retorno de "
#~ ":meth:`~flask.views.View.as_view`::"

#~ msgid ""
#~ "Starting with Flask 0.8 there is also an alternative way where you can "
#~ "specify a list of decorators to apply in the class declaration::"
#~ msgstr ""
#~ "A partir de Flask 0.8 existe también una forma alternativa en la que se "
#~ "puede especificar una lista de decoradores a aplicar en la declaración de la"
#~ " clase::"

#~ msgid ""
#~ "Due to the implicit self from the caller's perspective you cannot use "
#~ "regular view decorators on the individual methods of the view however, keep "
#~ "this in mind."
#~ msgstr ""
#~ "Debido a que el self está implícito desde la perspectiva de la persona que "
#~ "llama, no puedes usar decoradores de vista regulares en los métodos "
#~ "individuales de la vista, sin embargo, tenlo en cuenta."

#~ msgid "Method Views for APIs"
#~ msgstr "Vistas de métodos para APIs"

#~ msgid ""
#~ "Web APIs are often working very closely with HTTP verbs so it makes a lot of"
#~ " sense to implement such an API based on the "
#~ ":class:`~flask.views.MethodView`.  That said, you will notice that the API "
#~ "will require different URL rules that go to the same method view most of the"
#~ " time.  For instance consider that you are exposing a user object on the "
#~ "web:"
#~ msgstr ""
#~ "Las APIs de la web suelen trabajar muy estrechamente con los verbos HTTP por"
#~ " lo que tiene mucho sentido implementar una API de este tipo basada en la "
#~ ":class:`~flask.views.MethodView`. Dicho esto, te darás cuenta de que la API "
#~ "requerirá diferentes reglas de URL que vayan a la misma vista de método la "
#~ "mayoría de las veces. Por ejemplo, considera que estás exponiendo un objeto "
#~ "de usuario en la web:"

#~ msgid "``PUT``"
#~ msgstr "``PUT``"

#~ msgid ""
#~ "So how would you go about doing that with the "
#~ ":class:`~flask.views.MethodView`?  The trick is to take advantage of the "
#~ "fact that you can provide multiple rules to the same view."
#~ msgstr ""
#~ "Entonces, ¿cómo hacer eso con la :class:`~flask.views.MethodView`? El truco "
#~ "es aprovechar el hecho de que puedes proporcionar múltiples reglas a la "
#~ "misma vista."

#~ msgid "Let's assume for the moment the view would look like this::"
#~ msgstr "Asumamos por el momento que la vista se vería así::"

#~ msgid ""
#~ "So how do we hook this up with the routing system?  By adding two rules and "
#~ "explicitly mentioning the methods for each::"
#~ msgstr ""
#~ "Entonces, ¿cómo conectamos esto con el sistema de enrutamiento? Añadiendo "
#~ "dos reglas y mencionando explícitamente los métodos de cada una::"

#~ msgid ""
#~ "If you have a lot of APIs that look similar you can refactor that "
#~ "registration code::"
#~ msgstr ""
#~ "Si tienes muchas APIs que se parecen puedes refactorizar ese código de "
#~ "registro::"
