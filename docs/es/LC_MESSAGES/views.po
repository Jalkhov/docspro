# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010 Pallets
# This file is distributed under the same license as the Flask package.
# FIRST AUTHOR <pedrotorcattsoto@gmail.com>, 2021.
#
msgid ""
msgstr ""
"Project-Id-Version: Flask 2.0.x\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-05-27 07:20-0400\n"
"PO-Revision-Date: 2022-02-15 21:58-0400\n"
"Last-Translator: Pedro Torcatt <pedrotorcattsoto@gmail.com>\n"
"Language-Team: es_LA <pedrotorcattsoto@gmail.com>\n"
"Language: xd\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Generated-By: Babel 2.9.1\n"
"X-Generator: Poedit 3.0\n"

#: ../../views.rst:2
msgid "Pluggable Views"
msgstr "Vistas acoplables"

#: ../../views.rst:6
msgid ""
"Flask 0.7 introduces pluggable views inspired by the generic views from "
"Django which are based on classes instead of functions.  The main intention "
"is that you can replace parts of the implementations and this way have "
"customizable pluggable views."
msgstr ""
"Flask 0.7 introduce vistas acoplables inspiradas en las vistas genéricas de "
"Django que se basan en clases en lugar de funciones. La intención principal "
"es que puedas reemplazar partes de las implementaciones y de esta manera "
"tener vistas acoplables personalizables."

#: ../../views.rst:12
msgid "Basic Principle"
msgstr "Principio básico"

#: ../../views.rst:14
msgid ""
"Consider you have a function that loads a list of objects from the database "
"and renders into a template::"
msgstr ""
"Considere que tiene una función que carga una lista de objetos de la base de"
" datos y los renderiza en una plantilla::"

#: ../../views.rst:22
msgid ""
"This is simple and flexible, but if you want to provide this view in a "
"generic fashion that can be adapted to other models and templates as well "
"you might want more flexibility.  This is where pluggable class-based views "
"come into place.  As the first step to convert this into a class based view "
"you would do this::"
msgstr ""
"Esto es simple y flexible, pero si quieres proporcionar esta vista de forma "
"genérica que pueda ser adaptada a otros modelos y plantillas también podrías"
" querer más flexibilidad. Aquí es donde entran en juego las vistas basadas "
"en clases acoplables. Como primer paso para convertir esto en una vista "
"basada en clases se haría lo siguiente::"

#: ../../views.rst:39
msgid ""
"As you can see what you have to do is to create a subclass of "
":class:`flask.views.View` and implement "
":meth:`~flask.views.View.dispatch_request`.  Then we have to convert that "
"class into an actual view function by using the "
":meth:`~flask.views.View.as_view` class method.  The string you pass to that"
" function is the name of the endpoint that view will then have.  But this by"
" itself is not helpful, so let's refactor the code a bit::"
msgstr ""
"Como puedes ver lo que tienes que hacer es crear una subclase de "
":class:`flask.views.View` e implementar "
":meth:`~flask.views.View.dispatch_request`. Luego tenemos que convertir esa "
"clase en una función de vista real utilizando el método de clase "
":meth:`~flask.views.View.as_view`.  La cadena que se pasa a esa función es "
"el nombre del endpoint que tendrá esa vista. Pero esto por sí mismo no es "
"útil, así que vamos a refactorizar el código un poco::"

#: ../../views.rst:70
msgid ""
"This of course is not that helpful for such a small example, but it's good "
"enough to explain the basic principle.  When you have a class-based view the"
" question comes up what ``self`` points to.  The way this works is that "
"whenever the request is dispatched a new instance of the class is created "
"and the :meth:`~flask.views.View.dispatch_request` method is called with the"
" parameters from the URL rule.  The class itself is instantiated with the "
"parameters passed to the :meth:`~flask.views.View.as_view` function. For "
"instance you can write a class like this::"
msgstr ""
"Esto, por supuesto, no es tan útil para un ejemplo tan pequeño, pero es "
"suficiente para explicar el principio básico. Cuando se tiene una vista "
"basada en una clase surge la pregunta de a qué apunta ``self``. La forma en "
"que funciona es que cada vez que se despacha la petición se crea una nueva "
"instancia de la clase y se llama al método "
":meth:`~flask.views.View.dispatch_request` con los parámetros de la regla "
"URL. La propia clase se instanciará con los parámetros pasados a la función "
":meth:`~flask.views.View.as_view`. Por ejemplo, puedes escribir una clase "
"como esta::"

#: ../../views.rst:85
msgid "And then you can register it like this::"
msgstr "Y luego puedes registrarlo así::"

#: ../../views.rst:91
msgid "Method Hints"
msgstr "Consejos sobre el método"

#: ../../views.rst:93
msgid ""
"Pluggable views are attached to the application like a regular function by "
"either using :func:`~flask.Flask.route` or better "
":meth:`~flask.Flask.add_url_rule`.  That however also means that you would "
"have to provide the names of the HTTP methods the view supports when you "
"attach this.  In order to move that information to the class you can provide"
" a :attr:`~flask.views.View.methods` attribute that has this information::"
msgstr ""
"Las vistas conectables se adjuntan a la aplicación como una función normal "
"utilizando :func:`~flask.Flask.route` o mejor "
":meth:`~flask.Flask.add_url_rule`. Sin embargo, eso también significa que "
"tendrías que proporcionar los nombres de los métodos HTTP que la vista "
"soporta cuando adjuntas esto. Para trasladar esa información a la clase "
"puedes proporcionar un atributo :attr:`~flask.views.View.methods` que tenga "
"esta información::"

#: ../../views.rst:112
msgid "Method Based Dispatching"
msgstr "Despacho basado en el método"

#: ../../views.rst:114
msgid ""
"For RESTful APIs it's especially helpful to execute a different function for"
" each HTTP method.  With the :class:`flask.views.MethodView` you can easily "
"do that.  Each HTTP method maps to a method of the class with the same name "
"(just in lowercase)::"
msgstr ""
"Para las APIs RESTful es especialmente útil ejecutar una función diferente "
"para cada método HTTP.  Con la :class:`flask.views.MethodView` puedes "
"hacerlo fácilmente.  Cada método HTTP mapea a un método de la clase con el "
"mismo nombre (sólo en minúsculas)::"

#: ../../views.rst:133
msgid ""
"That way you also don't have to provide the "
":attr:`~flask.views.View.methods` attribute.  It's automatically set based "
"on the methods defined in the class."
msgstr ""
"De esta manera tampoco tienes que proporcionar el atributo "
":attr:`~flask.views.View.methods`.  Se establece automáticamente en función "
"de los métodos definidos en la clase."

#: ../../views.rst:138
msgid "Decorating Views"
msgstr "Decorando vistas"

#: ../../views.rst:140
msgid ""
"Since the view class itself is not the view function that is added to the "
"routing system it does not make much sense to decorate the class itself. "
"Instead you either have to decorate the return value of "
":meth:`~flask.views.View.as_view` by hand::"
msgstr ""
"Dado que la clase view en sí misma no es la función view que se añade al "
"sistema de enrutamiento, no tiene mucho sentido decorar la clase en sí "
"misma. En su lugar, hay que decorar a mano el valor de retorno de "
":meth:`~flask.views.View.as_view`::"

#: ../../views.rst:156
msgid ""
"Starting with Flask 0.8 there is also an alternative way where you can "
"specify a list of decorators to apply in the class declaration::"
msgstr ""
"A partir de Flask 0.8 existe también una forma alternativa en la que se "
"puede especificar una lista de decoradores a aplicar en la declaración de la"
" clase::"

#: ../../views.rst:162
msgid ""
"Due to the implicit self from the caller's perspective you cannot use "
"regular view decorators on the individual methods of the view however, keep "
"this in mind."
msgstr ""
"Debido a que el self está implícito desde la perspectiva de la persona que "
"llama, no puedes usar decoradores de vista regulares en los métodos "
"individuales de la vista, sin embargo, tenlo en cuenta."

#: ../../views.rst:167
msgid "Method Views for APIs"
msgstr "Vistas de métodos para APIs"

#: ../../views.rst:169
msgid ""
"Web APIs are often working very closely with HTTP verbs so it makes a lot of"
" sense to implement such an API based on the "
":class:`~flask.views.MethodView`.  That said, you will notice that the API "
"will require different URL rules that go to the same method view most of the"
" time.  For instance consider that you are exposing a user object on the "
"web:"
msgstr ""
"Las APIs de la web suelen trabajar muy estrechamente con los verbos HTTP por"
" lo que tiene mucho sentido implementar una API de este tipo basada en la "
":class:`~flask.views.MethodView`. Dicho esto, te darás cuenta de que la API "
"requerirá diferentes reglas de URL que vayan a la misma vista de método la "
"mayoría de las veces. Por ejemplo, considera que estás exponiendo un objeto "
"de usuario en la web:"

#: ../../views.rst:177
msgid "URL"
msgstr "URL"

#: ../../views.rst:177
msgid "Method"
msgstr "Método"

#: ../../views.rst:177
msgid "Description"
msgstr "Descripción"

#: ../../views.rst:179 ../../views.rst:180
msgid "``/users/``"
msgstr "``/users/``"

#: ../../views.rst:179 ../../views.rst:181
msgid "``GET``"
msgstr "``GET``"

#: ../../views.rst:179
msgid "Gives a list of all users"
msgstr "Da una lista de todos los usuarios"

#: ../../views.rst:180
msgid "``POST``"
msgstr "``POST``"

#: ../../views.rst:180
msgid "Creates a new user"
msgstr "Crea un nuevo usuario"

#: ../../views.rst:181 ../../views.rst:182 ../../views.rst:183
msgid "``/users/<id>``"
msgstr "``/users/<id>``"

#: ../../views.rst:181
msgid "Shows a single user"
msgstr "Muestra un solo usuario"

#: ../../views.rst:182
msgid "``PUT``"
msgstr "``PUT``"

#: ../../views.rst:182
msgid "Updates a single user"
msgstr "Actualiza un solo usuario"

#: ../../views.rst:183
msgid "``DELETE``"
msgstr "``DELETE``"

#: ../../views.rst:183
msgid "Deletes a single user"
msgstr "Elimina un solo usuario"

#: ../../views.rst:186
msgid ""
"So how would you go about doing that with the "
":class:`~flask.views.MethodView`?  The trick is to take advantage of the "
"fact that you can provide multiple rules to the same view."
msgstr ""
"Entonces, ¿cómo hacer eso con la :class:`~flask.views.MethodView`? El truco "
"es aprovechar el hecho de que puedes proporcionar múltiples reglas a la "
"misma vista."

#: ../../views.rst:190
msgid "Let's assume for the moment the view would look like this::"
msgstr "Asumamos por el momento que la vista se vería así::"

#: ../../views.rst:214
msgid ""
"So how do we hook this up with the routing system?  By adding two rules and "
"explicitly mentioning the methods for each::"
msgstr ""
"Entonces, ¿cómo conectamos esto con el sistema de enrutamiento? Añadiendo "
"dos reglas y mencionando explícitamente los métodos de cada una::"

#: ../../views.rst:224
msgid ""
"If you have a lot of APIs that look similar you can refactor that "
"registration code::"
msgstr ""
"Si tienes muchas APIs que se parecen puedes refactorizar ese código de "
"registro::"
