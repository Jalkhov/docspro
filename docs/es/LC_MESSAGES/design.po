# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010 Pallets
# This file is distributed under the same license as the Flask package.
# FIRST AUTHOR <pedrotorcattsoto@gmail.com>, 2021.
#
msgid ""
msgstr ""
"Project-Id-Version: Flask 2.0.x\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-05-27 07:20-0400\n"
"PO-Revision-Date: 2022-02-15 21:58-0400\n"
"Language-Team: es_LA <pedrotorcattsoto@gmail.com>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"Last-Translator: Pedro Torcatt <pedrotorcattsoto@gmail.com>\n"
"Language: es\n"
"X-Generator: Poedit 3.0\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../design.rst:2
msgid "Design Decisions in Flask"
msgstr "Decisiones de diseño en Flask"

#: ../../design.rst:4
msgid ""
"If you are curious why Flask does certain things the way it does and not "
"differently, this section is for you.  This should give you an idea "
"about some of the design decisions that may appear arbitrary and "
"surprising at first, especially in direct comparison with other "
"frameworks."
msgstr ""
"Si tienes curiosidad por saber por qué Flask hace ciertas cosas de la "
"manera que lo hace y no de otra manera, esta sección es para ti.  Esto "
"debería darte una idea sobre algunas de las decisiones de diseño que "
"pueden parecer arbitrarias y sorprendentes al principio, especialmente "
"en comparación directa con otros frameworks."

#: ../../design.rst:11
msgid "The Explicit Application Object"
msgstr "El objeto de aplicación explícito"

#: ../../design.rst:13
msgid ""
"A Python web application based on WSGI has to have one central callable "
"object that implements the actual application.  In Flask this is an "
"instance of the :class:`~flask.Flask` class.  Each Flask application has "
"to create an instance of this class itself and pass it the name of the "
"module, but why can't Flask do that itself?"
msgstr ""
"Una aplicación web de Python basada en WSGI tiene que tener un objeto "
"central llamable que implemente la aplicación real. En Flask esto es una "
"instancia de la clase :class:`~flask.Flask`. Cada aplicación Flask tiene "
"que crear una instancia de esta clase por sí misma y pasarle el nombre "
"del módulo, pero ¿por qué no puede hacerlo Flask por sí mismo?"

#: ../../design.rst:19
msgid "Without such an explicit application object the following code::"
msgstr "Sin ese objeto de aplicación explícito el siguiente código::"

#: ../../design.rst:28
msgid "Would look like this instead::"
msgstr "Se vería así en su lugar::"

#: ../../design.rst:36
msgid ""
"There are three major reasons for this.  The most important one is that "
"implicit application objects require that there may only be one instance "
"at the time.  There are ways to fake multiple applications with a single "
"application object, like maintaining a stack of applications, but this "
"causes some problems I won't outline here in detail.  Now the question "
"is: when does a microframework need more than one application at the "
"same time?  A good example for this is unit testing.  When you want to "
"test something it can be very helpful to create a minimal application to "
"test specific behavior.  When the application object is deleted "
"everything it allocated will be freed again."
msgstr ""
"Hay tres razones principales para ello. La más importante es que los "
"objetos de aplicación implícitos requieren que sólo pueda haber una "
"instancia a la vez. Hay formas de fingir múltiples aplicaciones con un "
"solo objeto de aplicación, como mantener una pila de aplicaciones, pero "
"esto causa algunos problemas que no voy a describir aquí en detalle. "
"Ahora la pregunta es: ¿cuándo necesita un microframework más de una "
"aplicación al mismo tiempo? Un buen ejemplo es el de las pruebas "
"unitarias."

#: ../../design.rst:47
msgid ""
"Another thing that becomes possible when you have an explicit object "
"lying around in your code is that you can subclass the base class (:"
"class:`~flask.Flask`) to alter specific behavior.  This would not be "
"possible without hacks if the object were created ahead of time for you "
"based on a class that is not exposed to you."
msgstr ""
"Otra cosa que se hace posible cuando tienes un objeto explícito en tu "
"código es que puedes subclasificar la clase base (:class:`~flask.Flask`) "
"para alterar un comportamiento específico. Esto no sería posible sin "
"hacks si el objeto se creara de antemano para usted basado en una clase "
"que no está expuesta a usted."

#: ../../design.rst:53
msgid ""
"But there is another very important reason why Flask depends on an "
"explicit instantiation of that class: the package name.  Whenever you "
"create a Flask instance you usually pass it `__name__` as package name. "
"Flask depends on that information to properly load resources relative to "
"your module.  With Python's outstanding support for reflection it can "
"then access the package to figure out where the templates and static "
"files are stored (see :meth:`~flask.Flask.open_resource`).  Now "
"obviously there are frameworks around that do not need any configuration "
"and will still be able to load templates relative to your application "
"module.  But they have to use the current working directory for that, "
"which is a very unreliable way to determine where the application is.  "
"The current working directory is process-wide and if you are running "
"multiple applications in one process (which could happen in a webserver "
"without you knowing) the paths will be off.  Worse: many webservers do "
"not set the working directory to the directory of your application but "
"to the document root which does not have to be the same folder."
msgstr ""
"Pero hay otra razón muy importante por la que Flask depende de una "
"instanciación explícita de esa clase: el nombre del paquete. Cada vez "
"que creas una instancia de Flask sueles pasarle `__name__` como nombre "
"del paquete. Flask depende de esa información para cargar correctamente "
"los recursos relativos a su módulo. Con el excelente soporte de Python "
"para la reflexión, puede acceder al paquete para averiguar dónde se "
"almacenan las plantillas y los archivos estáticos (ver :meth:`~flask."
"Flask.open_resource`). Ahora, obviamente, hay frameworks que no "
"necesitan ninguna configuración y todavía será capaz de cargar las "
"plantillas en relación con su módulo de aplicación."

#: ../../design.rst:70
msgid ""
"The third reason is \"explicit is better than implicit\".  That object "
"is your WSGI application, you don't have to remember anything else.  If "
"you want to apply a WSGI middleware, just wrap it and you're done "
"(though there are better ways to do that so that you do not lose the "
"reference to the application object :meth:`~flask.Flask.wsgi_app`)."
msgstr ""
"La tercera razón es que \"lo explícito es mejor que lo implícito\". Ese "
"objeto es tu aplicación WSGI, no tienes que recordar nada más. Si "
"quieres aplicar un middleware WSGI, simplemente envuélvelo y ya está "
"(aunque hay mejores formas de hacerlo para no perder la referencia al "
"objeto de la aplicación :meth:`~flask.Flask.wsgi_app`)."

#: ../../design.rst:76
msgid ""
"Furthermore this design makes it possible to use a factory function to "
"create the application which is very helpful for unit testing and "
"similar things (:doc:`/patterns/appfactories`)."
msgstr ""
"Además, este diseño permite utilizar una función de fábrica para crear "
"la aplicación, lo que es muy útil para las pruebas unitarias y cosas "
"similares (:doc:`/patterns/appfactories`)."

#: ../../design.rst:81
msgid "The Routing System"
msgstr "El sistema de enrutamiento"

#: ../../design.rst:83
msgid ""
"Flask uses the Werkzeug routing system which was designed to "
"automatically order routes by complexity.  This means that you can "
"declare routes in arbitrary order and they will still work as expected.  "
"This is a requirement if you want to properly implement decorator based "
"routing since decorators could be fired in undefined order when the "
"application is split into multiple modules."
msgstr ""
"Flask utiliza el sistema de enrutamiento Werkzeug que fue diseñado para "
"ordenar automáticamente las rutas por complejidad. Esto significa que "
"puedes declarar rutas en un orden arbitrario y seguirán funcionando como "
"se espera. Esto es un requisito si quieres implementar adecuadamente el "
"enrutamiento basado en decoradores, ya que los decoradores podrían "
"dispararse en un orden indefinido cuando la aplicación se divide en "
"múltiples módulos."

#: ../../design.rst:90
msgid ""
"Another design decision with the Werkzeug routing system is that routes "
"in Werkzeug try to ensure that URLs are unique.  Werkzeug will go quite "
"far with that in that it will automatically redirect to a canonical URL "
"if a route is ambiguous."
msgstr ""
"Otra decisión de diseño con el sistema de enrutamiento de Werkzeug es "
"que las rutas en Werkzeug intentan asegurar que las URLs son únicas.  "
"Werkzeug irá bastante lejos con eso en el sentido de que redirigirá "
"automáticamente a una URL canónica si una ruta es ambigua."

#: ../../design.rst:97
msgid "One Template Engine"
msgstr "Un motor de plantillas"

#: ../../design.rst:99
msgid ""
"Flask decides on one template engine: Jinja2.  Why doesn't Flask have a "
"pluggable template engine interface?  You can obviously use a different "
"template engine, but Flask will still configure Jinja2 for you.  While "
"that limitation that Jinja2 is *always* configured will probably go "
"away, the decision to bundle one template engine and use that will not."
msgstr ""
"Flask se decide por un motor de plantillas: Jinja2. ¿Por qué Flask no "
"tiene una interfaz de motor de plantillas enchufable?  Obviamente puedes "
"usar un motor de plantillas diferente, pero Flask seguirá configurando "
"Jinja2 por ti. Mientras que la limitación de que Jinja2 esté *siempre* "
"configurado probablemente desaparecerá, la decisión de agrupar un motor "
"de plantillas y utilizarlo no lo hará."

#: ../../design.rst:105
msgid ""
"Template engines are like programming languages and each of those "
"engines has a certain understanding about how things work.  On the "
"surface they all work the same: you tell the engine to evaluate a "
"template with a set of variables and take the return value as string."
msgstr ""
"Los motores de plantillas son como los lenguajes de programación y cada "
"uno de esos motores tiene un cierto entendimiento sobre cómo funcionan "
"las cosas.  En apariencia, todos funcionan igual: Le dices al motor que "
"evalúe una plantilla con un conjunto de variables y que tome el valor de "
"retorno como una cadena."

#: ../../design.rst:110
msgid ""
"But that's about where similarities end. Jinja2 for example has an "
"extensive filter system, a certain way to do template inheritance, "
"support for reusable blocks (macros) that can be used from inside "
"templates and also from Python code, supports iterative template "
"rendering, configurable syntax and more. On the other hand an engine "
"like Genshi is based on XML stream evaluation, template inheritance by "
"taking the availability of XPath into account and more. Mako on the "
"other hand treats templates similar to Python modules."
msgstr ""
"Pero ahí acaban las similitudes. Jinja2, por ejemplo, tiene un extenso "
"sistema de filtros, una cierta forma de hacer la herencia de plantillas, "
"soporte para bloques reutilizables (macros) que pueden ser usados desde "
"dentro de las plantillas y también desde el código Python, soporta la "
"renderización iterativa de plantillas, sintaxis configurable y más. Por "
"otro lado un motor como Genshi se basa en la evaluación de flujos XML, "
"herencia de plantillas teniendo en cuenta la disponibilidad de XPath y "
"más. Por otro lado, Mako trata las plantillas de forma similar a los "
"módulos de Python."

#: ../../design.rst:119
msgid ""
"When it comes to connecting a template engine with an application or "
"framework there is more than just rendering templates.  For instance, "
"Flask uses Jinja2's extensive autoescaping support.  Also it provides "
"ways to access macros from Jinja2 templates."
msgstr ""
"Cuando se trata de conectar un motor de plantillas con una aplicación o "
"un marco de trabajo, hay algo más que renderizar plantillas. Por "
"ejemplo, Flask utiliza el amplio soporte de autoescapado de Jinja2. "
"También proporciona formas de acceder a las macros desde las plantillas "
"de Jinja2."

#: ../../design.rst:124
msgid ""
"A template abstraction layer that would not take the unique features of "
"the template engines away is a science on its own and a too large "
"undertaking for a microframework like Flask."
msgstr ""
"Una capa de abstracción de plantillas que no elimine las características "
"únicas de los motores de plantillas es una ciencia en sí misma y una "
"empresa demasiado grande para un microframework como Flask."

#: ../../design.rst:128
msgid ""
"Furthermore extensions can then easily depend on one template language "
"being present.  You can easily use your own templating language, but an "
"extension could still depend on Jinja itself."
msgstr ""
"Además, las extensiones pueden depender fácilmente de la presencia de un "
"lenguaje de plantillas. Puedes utilizar fácilmente tu propio lenguaje de "
"plantillas, pero una extensión podría seguir dependiendo del propio "
"Jinja."

#: ../../design.rst:134
msgid "Micro with Dependencies"
msgstr "Micro con dependencias"

#: ../../design.rst:136
msgid ""
"Why does Flask call itself a microframework and yet it depends on two "
"libraries (namely Werkzeug and Jinja2).  Why shouldn't it?  If we look "
"over to the Ruby side of web development there we have a protocol very "
"similar to WSGI.  Just that it's called Rack there, but besides that it "
"looks very much like a WSGI rendition for Ruby.  But nearly all "
"applications in Ruby land do not work with Rack directly, but on top of "
"a library with the same name.  This Rack library has two equivalents in "
"Python: WebOb (formerly Paste) and Werkzeug.  Paste is still around but "
"from my understanding it's sort of deprecated in favour of WebOb.  The "
"development of WebOb and Werkzeug started side by side with similar "
"ideas in mind: be a good implementation of WSGI for other applications "
"to take advantage."
msgstr ""
"¿Por qué Flask se autodenomina microframework y sin embargo depende de "
"dos librerías (concretamente Werkzeug y Jinja2). ¿Por qué no debería "
"hacerlo? Si miramos hacia el lado de Ruby del desarrollo web tenemos un "
"protocolo muy similar a WSGI. Sólo que allí se llama Rack, pero aparte "
"de eso se parece mucho a una versión de WSGI para Ruby. Pero casi todas "
"las aplicaciones en la tierra de Ruby no trabajan con Rack directamente, "
"sino sobre una biblioteca con el mismo nombre. Esta biblioteca Rack "
"tiene dos equivalentes en Python: WebOb (antes Paste) y Werkzeug."

#: ../../design.rst:149
msgid ""
"Flask is a framework that takes advantage of the work already done by "
"Werkzeug to properly interface WSGI (which can be a complex task at "
"times).  Thanks to recent developments in the Python package "
"infrastructure, packages with dependencies are no longer an issue and "
"there are very few reasons against having libraries that depend on "
"others."
msgstr ""
"Flask es un framework que aprovecha el trabajo ya realizado por Werkzeug "
"para interconectar adecuadamente WSGI (lo que puede ser una tarea "
"compleja en ocasiones). Gracias a los recientes desarrollos en la "
"infraestructura de paquetes de Python, los paquetes con dependencias ya "
"no son un problema y hay muy pocas razones para no tener bibliotecas que "
"dependan de otras."

#: ../../design.rst:157
msgid "Thread Locals"
msgstr "Hilos Locales"

#: ../../design.rst:159
msgid ""
"Flask uses thread local objects (context local objects in fact, they "
"support greenlet contexts as well) for request, session and an extra "
"object you can put your own things on (:data:`~flask.g`).  Why is that "
"and isn't that a bad idea?"
msgstr ""
"Flask utiliza objetos locales de hilo (objetos locales de contexto, de "
"hecho, soportan contextos de Greenlet también) para la solicitud, la "
"sesión y un objeto extra en el que puedes poner tus propias cosas (:data:"
"`~flask.g`). ¿Por qué es eso y no es una mala idea?"

#: ../../design.rst:164
msgid ""
"Yes it is usually not such a bright idea to use thread locals.  They "
"cause troubles for servers that are not based on the concept of threads "
"and make large applications harder to maintain.  However Flask is just "
"not designed for large applications or asynchronous servers.  Flask "
"wants to make it quick and easy to write a traditional web application."
msgstr ""
"Sí, normalmente no es una idea tan brillante usar hilos locales. Causan "
"problemas en los servidores que no se basan en el concepto de hilos y "
"hacen que las aplicaciones grandes sean más difíciles de mantener. Sin "
"embargo, Flask no está diseñado para aplicaciones grandes o servidores "
"asíncronos. Flask quiere que sea rápido y fácil escribir una aplicación "
"web tradicional."

#: ../../design.rst:170
msgid ""
"Also see the :doc:`/becomingbig` section of the documentation for some "
"inspiration for larger applications based on Flask."
msgstr ""
"Consulta también la sección :doc:`/becomingbig` de la documentación para "
"inspirarte en aplicaciones más grandes basadas en Flask."

#: ../../design.rst:175
msgid "Async/await and ASGI support"
msgstr "Soporte de Async/await y ASGI"

#: ../../design.rst:177
msgid ""
"Flask supports ``async`` coroutines for view functions by executing the "
"coroutine on a separate thread instead of using an event loop on the "
"main thread as an async-first (ASGI) framework would. This is necessary "
"for Flask to remain backwards compatible with extensions and code built "
"before ``async`` was introduced into Python. This compromise introduces "
"a performance cost compared with the ASGI frameworks, due to the "
"overhead of the threads."
msgstr ""
"Flask soporta las coroutinas ``async`` para las funciones de la vista "
"ejecutando la coroutina en un hilo separado en lugar de usar un bucle de "
"eventos en el hilo principal como haría un framework async-first (ASGI). "
"Esto es necesario para que Flask siga siendo compatible con las "
"extensiones y el código construido antes de que ``async`` fuera "
"introducido en Python. Este compromiso introduce un coste de rendimiento "
"en comparación con los frameworks ASGI, debido a la sobrecarga de los "
"hilos."

#: ../../design.rst:185
msgid ""
"Due to how tied to WSGI Flask's code is, it's not clear if it's possible "
"to make the ``Flask`` class support ASGI and WSGI at the same time. Work "
"is currently being done in Werkzeug to work with ASGI, which may "
"eventually enable support in Flask as well."
msgstr ""
"Debido a lo ligado que está el código de Flask a WSGI, no está claro si "
"es posible hacer que la clase ``Flask`` soporte ASGI y WSGI al mismo "
"tiempo. Actualmente se está trabajando en Werkzeug para trabajar con "
"ASGI, lo que eventualmente podría permitir el soporte en Flask también."

#: ../../design.rst:190
msgid "See :doc:`/async-await` for more discussion."
msgstr "Ver :doc:`/async-await` para más información."

#: ../../design.rst:194
msgid "What Flask is, What Flask is Not"
msgstr "Qué es Flask, qué no es Flask"

#: ../../design.rst:196
msgid ""
"Flask will never have a database layer.  It will not have a form library "
"or anything else in that direction.  Flask itself just bridges to "
"Werkzeug to implement a proper WSGI application and to Jinja2 to handle "
"templating. It also binds to a few common standard library packages such "
"as logging. Everything else is up for extensions."
msgstr ""
"Flask nunca tendrá una capa de base de datos. No tendrá una biblioteca "
"de formularios ni nada en ese sentido. Flask en sí mismo sólo se une a "
"Werkzeug para implementar una aplicación WSGI adecuada y a Jinja2 para "
"manejar las plantillas. También se vincula a algunos paquetes de "
"bibliotecas estándar comunes, como el registro. Todo lo demás es para "
"las extensiones."

#: ../../design.rst:202
msgid ""
"Why is this the case?  Because people have different preferences and "
"requirements and Flask could not meet those if it would force any of "
"this into the core.  The majority of web applications will need a "
"template engine in some sort.  However not every application needs a SQL "
"database."
msgstr ""
"¿Por qué es así? Porque la gente tiene diferentes preferencias y "
"requisitos y Flask no podría satisfacerlos si forzara algo de esto en el "
"núcleo. La mayoría de las aplicaciones web necesitarán un motor de "
"plantillas de algún tipo. Sin embargo, no todas las aplicaciones "
"necesitan una base de datos SQL."

#: ../../design.rst:207
msgid ""
"The idea of Flask is to build a good foundation for all applications. "
"Everything else is up to you or extensions."
msgstr ""
"La idea de Flask es construir una buena base para todas las "
"aplicaciones. Todo lo demás depende de ti o de las extensiones."
