# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010 Pallets
# This file is distributed under the same license as the Flask package.
# FIRST AUTHOR <pedrotorcattsoto@gmail.com>, 2021.
#
msgid ""
msgstr ""
"Project-Id-Version: Flask 2.0.x\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-05-27 07:20-0400\n"
"PO-Revision-Date: 2022-02-15 21:58-0400\n"
"Last-Translator: Pedro Torcatt <pedrotorcattsoto@gmail.com>\n"
"Language-Team: es_LA <pedrotorcattsoto@gmail.com>\n"
"Language: xd\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Generated-By: Babel 2.9.1\n"
"X-Generator: Poedit 3.0\n"

#: ../../design.rst:2
msgid "Design Decisions in Flask"
msgstr "Decisiones de diseño en Flask"

#: ../../design.rst:4
msgid ""
"If you are curious why Flask does certain things the way it does and not "
"differently, this section is for you.  This should give you an idea about "
"some of the design decisions that may appear arbitrary and surprising at "
"first, especially in direct comparison with other frameworks."
msgstr ""
"Si tienes curiosidad por saber por qué Flask hace ciertas cosas de la manera"
" que lo hace y no de otra manera, esta sección es para ti.  Esto debería "
"darte una idea sobre algunas de las decisiones de diseño que pueden parecer "
"arbitrarias y sorprendentes al principio, especialmente en comparación "
"directa con otros frameworks."

#: ../../design.rst:11
msgid "The Explicit Application Object"
msgstr "El objeto de aplicación explícito"

#: ../../design.rst:13
msgid ""
"A Python web application based on WSGI has to have one central callable "
"object that implements the actual application.  In Flask this is an instance"
" of the :class:`~flask.Flask` class.  Each Flask application has to create "
"an instance of this class itself and pass it the name of the module, but why"
" can't Flask do that itself?"
msgstr ""
"Una aplicación web de Python basada en WSGI tiene que tener un objeto "
"central llamable que implemente la aplicación real. En Flask esto es una "
"instancia de la clase :class:`~flask.Flask`. Cada aplicación Flask tiene que"
" crear una instancia de esta clase por sí misma y pasarle el nombre del "
"módulo, pero ¿por qué no puede hacerlo Flask por sí mismo?"

#: ../../design.rst:19
msgid "Without such an explicit application object the following code::"
msgstr "Sin ese objeto de aplicación explícito el siguiente código::"

#: ../../design.rst:28
msgid "Would look like this instead::"
msgstr "Se vería así en su lugar::"

#: ../../design.rst:36
msgid ""
"There are three major reasons for this.  The most important one is that "
"implicit application objects require that there may only be one instance at "
"the time.  There are ways to fake multiple applications with a single "
"application object, like maintaining a stack of applications, but this "
"causes some problems I won't outline here in detail.  Now the question is: "
"when does a microframework need more than one application at the same time?"
"  A good example for this is unit testing.  When you want to test something "
"it can be very helpful to create a minimal application to test specific "
"behavior.  When the application object is deleted everything it allocated "
"will be freed again."
msgstr ""
"Hay tres razones principales para ello. La más importante es que los objetos"
" de aplicación implícitos requieren que sólo pueda haber una instancia a la "
"vez. Hay formas de fingir múltiples aplicaciones con un solo objeto de "
"aplicación, como mantener una pila de aplicaciones, pero esto causa algunos "
"problemas que no voy a describir aquí en detalle. Ahora la pregunta es: "
"¿cuándo necesita un microframework más de una aplicación al mismo tiempo? Un"
" buen ejemplo es el de las pruebas unitarias."

#: ../../design.rst:47
msgid ""
"Another thing that becomes possible when you have an explicit object lying "
"around in your code is that you can subclass the base class "
"(:class:`~flask.Flask`) to alter specific behavior.  This would not be "
"possible without hacks if the object were created ahead of time for you "
"based on a class that is not exposed to you."
msgstr ""
"Otra cosa que se hace posible cuando tienes un objeto explícito en tu código"
" es que puedes subclasificar la clase base (:class:`~flask.Flask`) para "
"alterar un comportamiento específico. Esto no sería posible sin hacks si el "
"objeto se creara de antemano para usted basado en una clase que no está "
"expuesta a usted."

#: ../../design.rst:53
msgid ""
"But there is another very important reason why Flask depends on an explicit "
"instantiation of that class: the package name.  Whenever you create a Flask "
"instance you usually pass it `__name__` as package name. Flask depends on "
"that information to properly load resources relative to your module.  With "
"Python's outstanding support for reflection it can then access the package "
"to figure out where the templates and static files are stored (see "
":meth:`~flask.Flask.open_resource`).  Now obviously there are frameworks "
"around that do not need any configuration and will still be able to load "
"templates relative to your application module.  But they have to use the "
"current working directory for that, which is a very unreliable way to "
"determine where the application is.  The current working directory is "
"process-wide and if you are running multiple applications in one process "
"(which could happen in a webserver without you knowing) the paths will be "
"off.  Worse: many webservers do not set the working directory to the "
"directory of your application but to the document root which does not have "
"to be the same folder."
msgstr ""
"Pero hay otra razón muy importante por la que Flask depende de una "
"instanciación explícita de esa clase: el nombre del paquete. Cada vez que "
"creas una instancia de Flask sueles pasarle `__name__` como nombre del "
"paquete. Flask depende de esa información para cargar correctamente los "
"recursos relativos a su módulo. Con el excelente soporte de Python para la "
"reflexión, puede acceder al paquete para averiguar dónde se almacenan las "
"plantillas y los archivos estáticos (ver "
":meth:`~flask.Flask.open_resource`). Ahora, obviamente, hay frameworks que "
"no necesitan ninguna configuración y todavía será capaz de cargar las "
"plantillas en relación con su módulo de aplicación."

#: ../../design.rst:70
msgid ""
"The third reason is \"explicit is better than implicit\".  That object is "
"your WSGI application, you don't have to remember anything else.  If you "
"want to apply a WSGI middleware, just wrap it and you're done (though there "
"are better ways to do that so that you do not lose the reference to the "
"application object :meth:`~flask.Flask.wsgi_app`)."
msgstr ""
"La tercera razón es que \"lo explícito es mejor que lo implícito\". Ese "
"objeto es tu aplicación WSGI, no tienes que recordar nada más. Si quieres "
"aplicar un middleware WSGI, simplemente envuélvelo y ya está (aunque hay "
"mejores formas de hacerlo para no perder la referencia al objeto de la "
"aplicación :meth:`~flask.Flask.wsgi_app`)."

#: ../../design.rst:76
msgid ""
"Furthermore this design makes it possible to use a factory function to "
"create the application which is very helpful for unit testing and similar "
"things (:doc:`/patterns/appfactories`)."
msgstr ""
"Además, este diseño permite utilizar una función de fábrica para crear la "
"aplicación, lo que es muy útil para las pruebas unitarias y cosas similares "
"(:doc:`/patterns/appfactories`)."

#: ../../design.rst:81
msgid "The Routing System"
msgstr "El sistema de enrutamiento"

#: ../../design.rst:83
msgid ""
"Flask uses the Werkzeug routing system which was designed to automatically "
"order routes by complexity.  This means that you can declare routes in "
"arbitrary order and they will still work as expected.  This is a requirement"
" if you want to properly implement decorator based routing since decorators "
"could be fired in undefined order when the application is split into "
"multiple modules."
msgstr ""
"Flask utiliza el sistema de enrutamiento Werkzeug que fue diseñado para "
"ordenar automáticamente las rutas por complejidad. Esto significa que puedes"
" declarar rutas en un orden arbitrario y seguirán funcionando como se "
"espera. Esto es un requisito si quieres implementar adecuadamente el "
"enrutamiento basado en decoradores, ya que los decoradores podrían "
"dispararse en un orden indefinido cuando la aplicación se divide en "
"múltiples módulos."

#: ../../design.rst:90
msgid ""
"Another design decision with the Werkzeug routing system is that routes in "
"Werkzeug try to ensure that URLs are unique.  Werkzeug will go quite far "
"with that in that it will automatically redirect to a canonical URL if a "
"route is ambiguous."
msgstr ""
"Otra decisión de diseño con el sistema de enrutamiento de Werkzeug es que "
"las rutas en Werkzeug intentan asegurar que las URLs son únicas.  Werkzeug "
"irá bastante lejos con eso en el sentido de que redirigirá automáticamente a"
" una URL canónica si una ruta es ambigua."

#: ../../design.rst:97
msgid "One Template Engine"
msgstr "Un motor de plantillas"

#: ../../design.rst:99
msgid ""
"Flask decides on one template engine: Jinja2.  Why doesn't Flask have a "
"pluggable template engine interface?  You can obviously use a different "
"template engine, but Flask will still configure Jinja2 for you.  While that "
"limitation that Jinja2 is *always* configured will probably go away, the "
"decision to bundle one template engine and use that will not."
msgstr ""
"Flask se decide por un motor de plantillas: Jinja2. ¿Por qué Flask no tiene "
"una interfaz de motor de plantillas enchufable?  Obviamente puedes usar un "
"motor de plantillas diferente, pero Flask seguirá configurando Jinja2 por "
"ti. Mientras que la limitación de que Jinja2 esté *siempre* configurado "
"probablemente desaparecerá, la decisión de agrupar un motor de plantillas y "
"utilizarlo no lo hará."

#: ../../design.rst:105
msgid ""
"Template engines are like programming languages and each of those engines "
"has a certain understanding about how things work.  On the surface they all "
"work the same: you tell the engine to evaluate a template with a set of "
"variables and take the return value as string."
msgstr ""
"Los motores de plantillas son como los lenguajes de programación y cada uno "
"de esos motores tiene un cierto entendimiento sobre cómo funcionan las "
"cosas.  En apariencia, todos funcionan igual: Le dices al motor que evalúe "
"una plantilla con un conjunto de variables y que tome el valor de retorno "
"como una cadena."

#: ../../design.rst:110
msgid ""
"But that's about where similarities end. Jinja2 for example has an extensive"
" filter system, a certain way to do template inheritance, support for "
"reusable blocks (macros) that can be used from inside templates and also "
"from Python code, supports iterative template rendering, configurable syntax"
" and more. On the other hand an engine like Genshi is based on XML stream "
"evaluation, template inheritance by taking the availability of XPath into "
"account and more. Mako on the other hand treats templates similar to Python "
"modules."
msgstr ""
"Pero ahí acaban las similitudes. Jinja2, por ejemplo, tiene un extenso "
"sistema de filtros, una cierta forma de hacer la herencia de plantillas, "
"soporte para bloques reutilizables (macros) que pueden ser usados desde "
"dentro de las plantillas y también desde el código Python, soporta la "
"renderización iterativa de plantillas, sintaxis configurable y más. Por otro"
" lado un motor como Genshi se basa en la evaluación de flujos XML, herencia "
"de plantillas teniendo en cuenta la disponibilidad de XPath y más. Por otro "
"lado, Mako trata las plantillas de forma similar a los módulos de Python."

#: ../../design.rst:119
msgid ""
"When it comes to connecting a template engine with an application or "
"framework there is more than just rendering templates.  For instance, Flask "
"uses Jinja2's extensive autoescaping support.  Also it provides ways to "
"access macros from Jinja2 templates."
msgstr ""
"Cuando se trata de conectar un motor de plantillas con una aplicación o un "
"marco de trabajo, hay algo más que renderizar plantillas. Por ejemplo, Flask"
" utiliza el amplio soporte de autoescapado de Jinja2. También proporciona "
"formas de acceder a las macros desde las plantillas de Jinja2."

#: ../../design.rst:124
msgid ""
"A template abstraction layer that would not take the unique features of the "
"template engines away is a science on its own and a too large undertaking "
"for a microframework like Flask."
msgstr ""
"Una capa de abstracción de plantillas que no elimine las características "
"únicas de los motores de plantillas es una ciencia en sí misma y una empresa"
" demasiado grande para un microframework como Flask."

#: ../../design.rst:128
msgid ""
"Furthermore extensions can then easily depend on one template language being"
" present.  You can easily use your own templating language, but an extension"
" could still depend on Jinja itself."
msgstr ""
"Además, las extensiones pueden depender fácilmente de la presencia de un "
"lenguaje de plantillas. Puedes utilizar fácilmente tu propio lenguaje de "
"plantillas, pero una extensión podría seguir dependiendo del propio Jinja."

#: ../../design.rst:134
msgid "Micro with Dependencies"
msgstr "Micro con dependencias"

#: ../../design.rst:136
msgid ""
"Why does Flask call itself a microframework and yet it depends on two "
"libraries (namely Werkzeug and Jinja2).  Why shouldn't it?  If we look over "
"to the Ruby side of web development there we have a protocol very similar to"
" WSGI.  Just that it's called Rack there, but besides that it looks very "
"much like a WSGI rendition for Ruby.  But nearly all applications in Ruby "
"land do not work with Rack directly, but on top of a library with the same "
"name.  This Rack library has two equivalents in Python: WebOb (formerly "
"Paste) and Werkzeug.  Paste is still around but from my understanding it's "
"sort of deprecated in favour of WebOb.  The development of WebOb and "
"Werkzeug started side by side with similar ideas in mind: be a good "
"implementation of WSGI for other applications to take advantage."
msgstr ""
"¿Por qué Flask se autodenomina microframework y sin embargo depende de dos "
"librerías (concretamente Werkzeug y Jinja2). ¿Por qué no debería hacerlo? Si"
" miramos hacia el lado de Ruby del desarrollo web tenemos un protocolo muy "
"similar a WSGI. Sólo que allí se llama Rack, pero aparte de eso se parece "
"mucho a una versión de WSGI para Ruby. Pero casi todas las aplicaciones en "
"la tierra de Ruby no trabajan con Rack directamente, sino sobre una "
"biblioteca con el mismo nombre. Esta biblioteca Rack tiene dos equivalentes "
"en Python: WebOb (antes Paste) y Werkzeug."

#: ../../design.rst:149
msgid ""
"Flask is a framework that takes advantage of the work already done by "
"Werkzeug to properly interface WSGI (which can be a complex task at times)."
"  Thanks to recent developments in the Python package infrastructure, "
"packages with dependencies are no longer an issue and there are very few "
"reasons against having libraries that depend on others."
msgstr ""
"Flask es un framework que aprovecha el trabajo ya realizado por Werkzeug "
"para interconectar adecuadamente WSGI (lo que puede ser una tarea compleja "
"en ocasiones). Gracias a los recientes desarrollos en la infraestructura de "
"paquetes de Python, los paquetes con dependencias ya no son un problema y "
"hay muy pocas razones para no tener bibliotecas que dependan de otras."

#: ../../design.rst:157
msgid "Thread Locals"
msgstr "Hilos Locales"

#: ../../design.rst:159
msgid ""
"Flask uses thread local objects (context local objects in fact, they support"
" greenlet contexts as well) for request, session and an extra object you can"
" put your own things on (:data:`~flask.g`).  Why is that and isn't that a "
"bad idea?"
msgstr ""
"Flask utiliza objetos locales de hilo (objetos locales de contexto, de "
"hecho, soportan contextos de Greenlet también) para la solicitud, la sesión "
"y un objeto extra en el que puedes poner tus propias cosas "
"(:data:`~flask.g`). ¿Por qué es eso y no es una mala idea?"

#: ../../design.rst:164
msgid ""
"Yes it is usually not such a bright idea to use thread locals.  They cause "
"troubles for servers that are not based on the concept of threads and make "
"large applications harder to maintain.  However Flask is just not designed "
"for large applications or asynchronous servers.  Flask wants to make it "
"quick and easy to write a traditional web application."
msgstr ""
"Sí, normalmente no es una idea tan brillante usar hilos locales. Causan "
"problemas en los servidores que no se basan en el concepto de hilos y hacen "
"que las aplicaciones grandes sean más difíciles de mantener. Sin embargo, "
"Flask no está diseñado para aplicaciones grandes o servidores asíncronos. "
"Flask quiere que sea rápido y fácil escribir una aplicación web tradicional."

#: ../../design.rst:170
msgid ""
"Also see the :doc:`/becomingbig` section of the documentation for some "
"inspiration for larger applications based on Flask."
msgstr ""
"Consulta también la sección :doc:`/becomingbig` de la documentación para "
"inspirarte en aplicaciones más grandes basadas en Flask."

#: ../../design.rst:175
msgid "Async/await and ASGI support"
msgstr "Soporte de Async/await y ASGI"

#: ../../design.rst:177
msgid ""
"Flask supports ``async`` coroutines for view functions by executing the "
"coroutine on a separate thread instead of using an event loop on the main "
"thread as an async-first (ASGI) framework would. This is necessary for Flask"
" to remain backwards compatible with extensions and code built before "
"``async`` was introduced into Python. This compromise introduces a "
"performance cost compared with the ASGI frameworks, due to the overhead of "
"the threads."
msgstr ""
"Flask soporta las coroutinas ``async`` para las funciones de la vista "
"ejecutando la coroutina en un hilo separado en lugar de usar un bucle de "
"eventos en el hilo principal como haría un framework async-first (ASGI). "
"Esto es necesario para que Flask siga siendo compatible con las extensiones "
"y el código construido antes de que ``async`` fuera introducido en Python. "
"Este compromiso introduce un coste de rendimiento en comparación con los "
"frameworks ASGI, debido a la sobrecarga de los hilos."

#: ../../design.rst:185
msgid ""
"Due to how tied to WSGI Flask's code is, it's not clear if it's possible to "
"make the ``Flask`` class support ASGI and WSGI at the same time. Work is "
"currently being done in Werkzeug to work with ASGI, which may eventually "
"enable support in Flask as well."
msgstr ""
"Debido a lo ligado que está el código de Flask a WSGI, no está claro si es "
"posible hacer que la clase ``Flask`` soporte ASGI y WSGI al mismo tiempo. "
"Actualmente se está trabajando en Werkzeug para trabajar con ASGI, lo que "
"eventualmente podría permitir el soporte en Flask también."

#: ../../design.rst:190
msgid "See :doc:`/async-await` for more discussion."
msgstr "Ver :doc:`/async-await` para más información."

#: ../../design.rst:194
msgid "What Flask is, What Flask is Not"
msgstr "Qué es Flask, qué no es Flask"

#: ../../design.rst:196
msgid ""
"Flask will never have a database layer.  It will not have a form library or "
"anything else in that direction.  Flask itself just bridges to Werkzeug to "
"implement a proper WSGI application and to Jinja2 to handle templating. It "
"also binds to a few common standard library packages such as logging. "
"Everything else is up for extensions."
msgstr ""
"Flask nunca tendrá una capa de base de datos. No tendrá una biblioteca de "
"formularios ni nada en ese sentido. Flask en sí mismo sólo se une a Werkzeug"
" para implementar una aplicación WSGI adecuada y a Jinja2 para manejar las "
"plantillas. También se vincula a algunos paquetes de bibliotecas estándar "
"comunes, como el registro. Todo lo demás es para las extensiones."

#: ../../design.rst:202
msgid ""
"Why is this the case?  Because people have different preferences and "
"requirements and Flask could not meet those if it would force any of this "
"into the core.  The majority of web applications will need a template engine"
" in some sort.  However not every application needs a SQL database."
msgstr ""
"¿Por qué es así? Porque la gente tiene diferentes preferencias y requisitos "
"y Flask no podría satisfacerlos si forzara algo de esto en el núcleo. La "
"mayoría de las aplicaciones web necesitarán un motor de plantillas de algún "
"tipo. Sin embargo, no todas las aplicaciones necesitan una base de datos "
"SQL."

#: ../../design.rst:207
msgid ""
"The idea of Flask is to build a good foundation for all applications. "
"Everything else is up to you or extensions."
msgstr ""
"La idea de Flask es construir una buena base para todas las aplicaciones. "
"Todo lo demás depende de ti o de las extensiones."
